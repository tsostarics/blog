[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Pulse Labeling\n\n\n\n\n\n\n\nR\n\n\nPraat\n\n\n\n\nThis post discusses using non-equi joins to label pitch pulses by an interval on a TextGrid.\n\n\n\n\n\n\nJan 25, 2023\n\n\nThomas Sostarics\n\n\n\n\n\n\n\n\nContrastable\n\n\n\n\n\n\n\nR pkg\n\n\n\n\nThis post gives an overview of an R package I’ve written. The contrastable package provides a tidy approach to contrast coding for regression analyses.\n\n\n\n\n\n\nJul 13, 2022\n\n\nThomas Sostarics\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/contrastable/index.html",
    "href": "posts/contrastable/index.html",
    "title": "Contrastable",
    "section": "",
    "text": "I’ve been working on a package called contrastable on and off for the past year or so. The package’s goal is to provide a tidy approach to setting factor contrasts for regression analysis. While this can be done with repeated contrasts<- calls, this workflow is tedious when working with multiple factors and especially error-prone when manually specifying contrast matrices to use. In this latter case, the user would need to be careful to specify the correct fractions in the correct order with the correct signs, which can be a lot to keep track of. These issues quickly become apparent when the number of factor levels is greater than 2. In this post I will:"
  },
  {
    "objectID": "posts/contrastable/index.html#contrasts-overview",
    "href": "posts/contrastable/index.html#contrasts-overview",
    "title": "Contrastable",
    "section": "Contrasts overview",
    "text": "Contrasts overview\nContrast coding refers to assigning numeric values to levels of a categorical variable for use in regression analyses. Depending on the numbers used, different comparisons can be made between the group means of a variable. These comparisons can correspond to particular null hypotheses that a researcher might have, and particular combinations of numbers can encode high-level questions like “Are there differences between levels when compared to a common reference level?” or “Does each level differ from the levels that came before it?” Critically, the contrasts used don’t impact the model fit but do impact the coefficient estimates that are used to make inferences about the data. For example, you might conclude that there’s an overall effect of some factor when in reality the effect (shown by the coefficient estimate) is an effect that only holds for one particular group!\nConsider an example where you have two groups of listeners where English is their native (L1) or non-native (L2) language. You might be interested in whether reading times are slower or faster in two different syntactic conditions, such as active vs passive constructions. Two possible research questions might be whether there’s an main effect of syntax on reading times on the one hand or whether there’s a simple effect such that reading times in the passive construction are only slower for L2 speakers.1 These are similar, but different, research questions and more importantly, the interpretation of one coefficient depends on how other variables are coded. Many researchers realize (or are starting to at least) that the default2 “0/1 contrasts” (aka treatment or dummy coding) will only give them the simple effect of structure, but if what you’re interested in is that main effect, then your statistics has not yet answered your question! To rectify this, researchers will opt for “the +.5/-.5 contrasts” to obtain main effects.\n\n\n\n\n\n\nWarning: Naming inconsistency\n\n\n\nThe name for this contrast scheme is not consistent, especially in the 2-level case where the values are +.5/-.5. I’ve seen it called sum coding, simple coding, effects coding, scaled sum coding, helmert coding, difference coding, contrast coding, sum-to-zero coding, and +.5/-.5 coding. See Brehm and Alday (2022) for concerns about transparent descriptions of contrast coding schemes.\n\n\nWhile researchers may differ on what they call +.5/-.5, for 2 levels the result is nonetheless the same. But, a researcher using “helmert coding” and a researcher using “scaled sum coding” for a factor with 3 or more levels will be using very different contrast matrices, and thus address very different research questions about the data. Let’s use some functions from contrastable to look at how these contrast matrices differ.\n\nlibrary(contrastable)\n\n\n2 levels3 levels5 levels\n\n\n\nhelmert_code(2) |> MASS::fractions()\n\n     [,1]\n[1,]  1/2\n[2,] -1/2\n\nscaled_sum_code(2) |> MASS::fractions()\n\n  [,1]\n1  1/2\n2 -1/2\n\n\n\n\n\nhelmert_code(3) |> MASS::fractions()\n\n     [,1] [,2]\n[1,]  2/3    0\n[2,] -1/3  1/2\n[3,] -1/3 -1/2\n\nscaled_sum_code(3) |> MASS::fractions()\n\n  [,1] [,2]\n1  2/3 -1/3\n2 -1/3  2/3\n3 -1/3 -1/3\n\n\n\n\n\nhelmert_code(5) |> MASS::fractions()\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\nscaled_sum_code(5) |> MASS::fractions()\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\nNote that I use the term scaled sum coding for the “pairwise comparisons with main effects” contrast scheme. I opt for this term for three reasons.\n\nFirst, I see sum coding used more frequently in statistics and econometrics to refer to +1/-1; this is also what contr.sum in R returns.\nSecond, the salient part of going from sum coding to scaled sum coding, especially in the 2-level case, is that there’s some kind of division or scaling operation involved; I frequently see people use contr.sum(2)/2, although importantly contr.sum(3)/3 does not yield the expected result.\nThird, “simple” coding is counterintuitive to me since we’re trying to avoid “simple effects;” “effects coding” and “contrast coding” are largely meaningless as all coding schemes will encode some kind of effect, and setting any contrast matrix is an instance of contrast coding.\n\nSo, for the researcher trying to remember “I need to use those contrasts where they’re divided to get the main effects”, it (to me) seems easy to reach for a tool where scaled is in the name and is clearly distinguished from sum coding. 3"
  },
  {
    "objectID": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "href": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "title": "Contrastable",
    "section": "Typical approach to contrast coding",
    "text": "Typical approach to contrast coding\nTypically when I see people in Linguistics set contrasts, they do something like the following, using the palmerpenguins dataset as an example.\n\n\nCode\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins_with_contrasts <- penguins\n\n# Default treatment/dummy coding for a 2 and 3 level factor\ncontrasts(penguins_with_contrasts$sex)\n\n\n       male\nfemale    0\nmale      1\n\n\nCode\ncontrasts(penguins_with_contrasts$species)\n\n\n          Chinstrap Gentoo\nAdelie            0      0\nChinstrap         1      0\nGentoo            0      1\n\n\nCode\n# Easy enough for 2 levels, -contr.sum(2)/2 is also used a lot\ncontrasts(penguins_with_contrasts$sex) <- c(-.5, .5) \n\n# Not so fun for three levels!\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 2/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\n\n\nThe chance of making a mistake increases when including more and more categorical variables. Catching these mistakes can be very difficult, in part because this workflow erases the labels in the regression output. This means you have to keep track of what 1 and 2 in the regression coefficients correspond to.\n\n\n\n\n\n\nNote: Column/Comparison/Coefficient names\n\n\n\nWhile the dimnames argument can be used to set the labels, anecdotally I rarely see people use this in their analyses when perusing code on the osf. Winter (2019, 127) notes that “Using the ‘1’ after the predictor name is a notational convention for representing the slopes of sum-coded predictors in R” but this is slightly incorrect; in the absence of dimnames being set, R will use the numeric indices of the contrast matrix’s columns (no matter what the scheme is).\n\n\nBelow, the two sets of coefficients represent pairwise comparisons to the Adelie baseline, but the intercepts differ due to how the contrasts are set, with the first using treatment coding and the second using scaled sum coding. I’ll start with a case that only considers the categorical variable, but will include an additional continuous independent variable later on.\n\n\nCode\n# Compare the default treatment coding with the penguins dataset\n# with the contrasts we specified in penguins_with_contrasts\ntreatment_coefs <- coef(lm(bill_length_mm ~ species,\n                           data = penguins))    \nscaledsum_coefs <- coef(lm(bill_length_mm ~ species, \n                           data = penguins_with_contrasts)) \n\n# I'm using list() to print and caption results side by side, purely aesthetic\nlist(\"(Default) Treatment Coding\" = treatment_coefs,\n     \"(Manual) Scaled Sum Coding\" = scaledsum_coefs)\n\n\n$`(Default) Treatment Coding`\n     (Intercept) speciesChinstrap    speciesGentoo \n       38.791391        10.042433         8.713487 \n\n$`(Manual) Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nThe model coefficients for the scaled sum coding shows the same pairwise comparisons as the model using treatment coding, but the intercepts differ. We can check what they correspond to manually:\n\n\nCode\ngroup_means <- \n  penguins |>\n  dplyr::group_by(species) |> \n  dplyr::summarize(mean_length = mean(bill_length_mm, na.rm = TRUE)) |> \n  purrr::pluck('mean_length') |> \n  `names<-`(c('Adelie', 'Chinstrap', 'Gentoo'))\n\nlist(\"Group means\"= group_means,\n     \"Grand mean\" = mean(group_means))\n\n\n$`Group means`\n   Adelie Chinstrap    Gentoo \n 38.79139  48.83382  47.50488 \n\n$`Grand mean`\n[1] 45.04336\n\n\nSo the intercept for the treatment coded model is the mean of the Adelie group while the scaled sum coded model is the grand mean, or the mean of group means. But, typing in the scaled sum contrast matrix was a bit obnoxious with all the -1/3 we typed. If we had made a slight mistake while typing the matrix out, what would have happened to our model? Would our coefficients reflect the averages and differences we were expecting? As an example, let’s see what happens when we change a 2/3 to 1/3:\n\n\nCode\n# What if we accidentally typed 1/3 instead of 2/3?\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 1/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\nmistake_coefs <- coef(lm(bill_length_mm ~ species, \n                         data = penguins_with_contrasts))\n\nlist(\"(Current) Mistaken Scaled Sum Coding:\" = mistake_coefs,\n     \"(Previous) Correct Scaled Sum Coding:\" = scaledsum_coefs)\n\n\n$`(Current) Mistaken Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`(Previous) Correct Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nHere we can see that the intercept and the value for species1 have increased in magnitude. In particular, the new reported effect of species1 is much larger than it previously was. If we stopped at this point, we would conclude that the difference in bill length between the Chinstrap and Adelie groups is a whopping 15mm (remember we originally calculated it to be about 10). If we were interested in whether there was a positive or negative difference that was significant or not, we’d still make that conclusion, but any claims about the magnitude of the effect would be misguided. This problem opens up a related question though: What does this new inflated-in-magitude coefficient estimate represent?\n\nDiagnosing our mistake\nTo check what these numbers correspond to, we have to check the hypothesis matrix that corresponds to our contrast matrix. The process of obtaining the hypothesis matrix has been referred to as finding the generalized inverse of the contrast matrix (see Schad et al. 2020 for details).\n\n\nCode\nmatrix(c(1, 1, 1,         # Add a column of 1s for the intercept\n         -1/3, 1/3, -1/3,\n         -1/3, -1/3, 2/3),\n       nrow = 3,\n       dimnames = list(NULL, c('Intercept', 'species1', 'species2'))) |> \n  t() |> \n  solve() |> \n  MASS::fractions() # This function just shows numbers as fractions\n\n\n     Intercept species1 species2\n[1,]  1/6      -3/2       -1    \n[2,]  1/2       3/2        0    \n[3,]  1/3         0        1    \n\n\nHere the intercept is represented by the weighted sum of each group mean, where the weights are shown in the intercept column. In most cases, the intercept should reflect the grand mean, or the mean of the group means, and so would usually have equal weights (i.e., 1/3 here) for the levels. In this case, we see the fractional weights are not the same. We can verify this by calculating the weighted mean ourselves:\n\n\nCode\nlist(\"Grand Mean\" = mean(group_means),\n     \"Weighted mean\" = weighted.mean(group_means, c(1/6, 1/2, 1/3)))\n\n\n$`Grand Mean`\n[1] 45.04336\n\n$`Weighted mean`\n[1] 46.7171\n\n\nSimilarly, the coefficient for species1 shows the difference between the group means of levels 1 and 2 (i.e., mean of Chinstrap - mean of Adelie) but times a factor of 3/2. Crucially, if our goal is to evaluate the difference between the means of these two levels, then our mistake in coding the hypothesis matrix will give us a larger estimate (~15 vs 10). Consider a similar setup where the larger estimate was 5 instead of 0; if we were relying on null hypothesis testing it’s possible we’d get a significant effect when really we shouldn’t have.\n\n\nCode\nlist(\"Mistaken Scaled Sum Coding\" = mistake_coefs,\n     \"Correct Scaled Sum Coding\" = scaledsum_coefs,\n     \"Computed Chinstrap-Adelie Difference with 3/2 scaling\" = \n       (3/2 * group_means[['Chinstrap']]) - (3/2 * group_means[['Adelie']]),\n     \"Actual Chinstrap-Adelie Difference\" = \n       group_means[['Chinstrap']] - group_means[['Adelie']])\n\n\n$`Mistaken Scaled Sum Coding`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`Correct Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n$`Computed Chinstrap-Adelie Difference with 3/2 scaling`\n[1] 15.06365\n\n$`Actual Chinstrap-Adelie Difference`\n[1] 10.04243\n\n\nPoint being: we made an honest mistake of typing 1/3 instead of 2/3 but this had ramifications for the coefficients in our model output that we use to make inferences. In practice, because we did the multiple contrasts<- calls, we would likely assume that what we did was correct in the absence of any errors."
  },
  {
    "objectID": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "href": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "title": "Contrastable",
    "section": "Tidy approach to contrasts",
    "text": "Tidy approach to contrasts\nHere I’ll show a different approach using the contrastable package. This package takes a tidy approach to take care of the overhead of labels and reference levels involved when using common contrast coding schemes. Specifically, this package provides a series of functions that use a special formula implementation that assigns specific meanings to each operator. The left hand side of the formula is the factor column whose contrasts you want to change. The right hand side consists of (at minimum) a function to generate contrast matrices such as contr.treatment or treatment_code. Additional operators provide extra optional functionality:\n\n+ x: Set reference level to level x\n* x: Set intercept to be the mean of x\n- 3:4: For polynomial contrasts only, drop trends 3 and 4\n| c(\"A-B\", \"A-C\"): Set the comparison labels to A-B and A-C (must be the last operator if used)\n\nRecall that in many cases researchers want pairwise comparisons while retaining main effects, and so the choice of reference level for the comparisons is very important. By default, R uses the first level alphabetically as the reference level, but sometimes we want to change this manually ourselves. Here’s an example where we set the sex and species factors to the two contrast schemes we manually set before. The set_contrasts function will show a message if it detects additional factor variables in the dataframe that the user did not provide contrasts for.\n\n\nCode\n# library(contrastable) was loaded earlier\npenguins_df <- \n  penguins |> \n  set_contrasts(sex ~ scaled_sum_code + \"male\", # Set reference level with +\n                species ~ scaled_sum_code + 'Adelie') \n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\nCode\ncontrasts(penguins_df$species) |> MASS::fractions()\n\n\n          Chinstrap Gentoo\nAdelie    -1/3      -1/3  \nChinstrap  2/3      -1/3  \nGentoo    -1/3       2/3  \n\n\nCode\ncontrasts(penguins_df$sex) |> MASS::fractions()\n\n\n       female\nfemale  1/2  \nmale   -1/2  \n\n\npenguins_df now has its contrasts set, and we can run our model as usual. Note that we didn’t have to type out any matrices ourselves, but we got the correct contrasts that we needed.\n\n\nCode\ncoef(lm(bill_length_mm ~ species + bill_depth_mm, data = penguins_df))\n\n\n     (Intercept) speciesChinstrap    speciesGentoo    bill_depth_mm \n       20.997115         9.938955        13.403279         1.394011 \n\n\nIf we wanted to change the labels to better reflect the comparisons being made, we could do that in the formula too with the | operator.\n\n\nCode\npenguins_df <- \n  penguins_df |> \n  set_contrasts(species ~ scaled_sum_code + 'Adelie' | \n                  c('Chinstrap-Ad', 'Gentoo-Ad'))\n\ncoef(lm(bill_length_mm ~ species, data = penguins_df))\n\n\n        (Intercept) speciesChinstrap-Ad    speciesGentoo-Ad \n          45.043364           10.042433            8.713487 \n\n\n\nAdditional functions\nTypically when I use this package in my analyses the set_contrasts function is all I really need, but there are other functions that follow the same syntax that provide other information. To avoid retyping things, I’ll usually keep the contrasts in a list assigned to a separate variable and pass that to functions.\nThe glimpse_contrasts function can show information about the factors in a dataset along with the contrast schemes that have been assigned to each factor.\n\n\nCode\nmy_contrasts <- \n  list(\n    sex ~ scaled_sum_code + 'female',\n    species ~ helmert_code\n  )\n\nglimpse_contrasts(penguins_df, my_contrasts) |> gt::gt()\n\n\n\n\n\n\n  \n  \n    \n      factor\n      n_levels\n      level_names\n      scheme\n      reference\n      intercept\n      orthogonal\n      centered\n      dropped_trends\n      explicitly_set\n    \n  \n  \n    sex\n2\nfemale, male\nscaled_sum_code\nfemale\ngrand mean\nNA\nTRUE\nNA\nTRUE\n    species\n3\nAdelie, Chinstrap, Gentoo\nhelmert_code\nGentoo\ngrand mean\nTRUE\nTRUE\nNA\nTRUE\n    island\n3\nBiscoe, Dream, Torgersen\ncontr.treatment\nBiscoe\nmean(Biscoe)\nFALSE\nFALSE\nNA\nFALSE\n  \n  \n  \n\n\n\n\nThe enlist_contrasts function does the same thing as set_contrasts, but returns a list of contrast matrices that can be used in the contrasts argument of some model-fitting functions.4 It also provides an easy way to show the contrast matrices in an appendix or supplementary material.\n\n\nCode\nenlist_contrasts(penguins_df, my_contrasts) |> purrr::map(MASS::fractions)\n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\n$sex\n       male\nfemale -1/2\nmale    1/2\n\n$species\n          >Adelie >Chinstrap\nAdelie     2/3       0      \nChinstrap -1/3     1/2      \nGentoo    -1/3    -1/2      \n\n\n\n\nAvailable contrast schemes\nHere are the different contrast functions this package currently provides.\n\nTreatmentSumScaled SumHelmertReverse HelmertForward DifferenceBackward DifferenceOrthogonal PolynomialsRaw Polynomials\n\n\n\n\nCode\n# = contr.treatment\ntreatment_code(5) |> MASS::fractions()\n\n\n  2 3 4 5\n1 0 0 0 0\n2 1 0 0 0\n3 0 1 0 0\n4 0 0 1 0\n5 0 0 0 1\n\n\n\n\n\n\nCode\n# = contr.sum\nsum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  1    0    0    0  \n2  0    1    0    0  \n3  0    0    1    0  \n4  0    0    0    1  \n5 -1   -1   -1   -1  \n\n\n\n\n\n\nCode\n# = contr.sum\nscaled_sum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\n\nCode\n# NOT = contr.helmert, which is unscaled\nhelmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\n\n\n\n\n\nCode\nreverse_helmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -1/2 -1/3 -1/4 -1/5\n[2,]  1/2 -1/3 -1/4 -1/5\n[3,]    0  2/3 -1/4 -1/5\n[4,]    0    0  3/4 -1/5\n[5,]    0    0    0  4/5\n\n\n\n\n\n\nCode\nforward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5  3/5  2/5  1/5\n[2,] -1/5  3/5  2/5  1/5\n[3,] -1/5 -2/5  2/5  1/5\n[4,] -1/5 -2/5 -3/5  1/5\n[5,] -1/5 -2/5 -3/5 -4/5\n\n\n\n\n\n\nCode\nbackward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -4/5 -3/5 -2/5 -1/5\n[2,]  1/5 -3/5 -2/5 -1/5\n[3,]  1/5  2/5 -2/5 -1/5\n[4,]  1/5  2/5  3/5 -1/5\n[5,]  1/5  2/5  3/5  4/5\n\n\n\n\n\n\nCode\n# = contr.poly, poly(1:n, degree = n-1, raw = FALSE)\north_polynomial_code(5) |> MASS::fractions()\n\n\n     .L                .Q                .C                ^4               \n[1,]          -265/419          929/1738  -2026009/6406803        4018/33617\n[2,]  -2026009/6406803         -809/3027           191/302    -246481/515552\n[3,]                 0       -6263/11717                 0         1042/1453\n[4,] 12484830/39480499         -809/3027          -265/419    -246481/515552\n[5,]           191/302          929/1738 10458821/33073696        4018/33617\n\n\n\n\n\n\nCode\n# = poly(1:n, degree = n-1, raw = TRUE)\nraw_polynomial_code(5) |> MASS::fractions()\n\n\n     1   2   3   4  \n[1,]   1   1   1   1\n[2,]   2   4   8  16\n[3,]   3   9  27  81\n[4,]   4  16  64 256\n[5,]   5  25 125 625"
  },
  {
    "objectID": "posts/contrastable/index.html#other-packages-and-resources",
    "href": "posts/contrastable/index.html#other-packages-and-resources",
    "title": "Contrastable",
    "section": "Other packages and resources",
    "text": "Other packages and resources\nThis package is not the first package made for contrast coding, though to my knowledge it is the first to take a “tidy” approach to it.\nThe hypr package (Rabe et al. 2020) takes a different approach, where the focus is on considering the hypothesis matrix and declaring specifically which comparisons you want to make, then the package can provide a corresponding matrix. I like hypr a lot actually, but I find it a bit tedious when I know what the contrast matrix should look like but I have to type out the comparisons; still better than matrix calls though.\nThe emmeans package (Lenth 2022) is extremely useful for making pairwise comparisons, but is capable of a lot more as well. You can see its vignette on contrasts here.\nThe multcomp package (Hothorn, Bretz, and Westfall 2008) is useful for simultaneous inference, which seeks to extend workflows for multiple comparisons.\nI haven’t used the contrasts package (O’Callaghan 2021) very much, but judging from its vignette here it seems like it extends the rms package’s contrast function (Harrell Jr 2022). It seems useful for calculating different comparisons after a model is run, but its usage isn’t very transparent to me on first glance.\nWhile not a package, this page from UCLA pops up a lot when people discuss contrast coding. It’s very useful, and I used it as a starting point for implementing different contrast functions. However, I will note that I don’t follow its naming conventions."
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html",
    "href": "posts/pulselabeling/pulse_labeling.html",
    "title": "Pulse Labeling",
    "section": "",
    "text": "A colleague of mine recently asked for help with a bit of a tricky problem. Pitch contours, when extracted from an acoustic signal, come in the form of a time series of discretized pulses: a (time, frequency) point. However, these contours occur over varying parts of the spoken sentence. In other words, the rises and falls in pitch occur over different words, syllables, and phones– all of which have varying durations. If we take a pitch contour over a single word from the productions of many speakers, then time normalize them, we don’t have access to the relative durations and landmarks of the syllables that make up the token. For instance, if two speakers rise from 110Hz to 220Hz over one syllable, this rise will be much steeper if the first syllable is 30% of the time normalized duration compared to if the first syllable is 60% of the time normalized duration. The problem then becomes two related problems:\nAs it happens, this problem becomes fairly straightforward when using non-equi joins. These are joins (left, right, etc.) that match not merely on equivalence matching, but when more complex logical operations need to be used. In our case, we want to merge information about the pulses and their timestamps with information about the syllable boundary timestamps. We can accomplish this by joining two dataframes based on whether the pulse timestamp is between the start and end timestamps of a particular interval.\nIn this post, I’ll show how this can be accomplished in R using the new non-equi join functionality added to {dplyr} version 1.1. In the process, I’ll also show off some tools from the {rPraat} package and the {sosprosody} package, which I am developing to support the analyses and data processing for my dissertation work. These packages provide some useful functionality for working with PitchTier and TextGrid objects from Praat. However, this functionality can also be accomplished through any non-equi join implementation. I’m familiar with the {fuzzyjoin} package, and this post provides some additional options."
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#required-packages",
    "href": "posts/pulselabeling/pulse_labeling.html#required-packages",
    "title": "Pulse Labeling",
    "section": "Required packages",
    "text": "Required packages\nSee below code block for installation of the most relevant packages. {dplyr} must be version 1.1/the development version (as of this writing) to allow for non-equi/fuzzy joins, and so is not (yet) part of a typical installation of tidyverse.1 Refer to below code block for installation.\n\n\nCode\n# devtools or remotes can be used to install from github\ndevtools::install_github(\"tidyverse/dplyr\")\ninstall.packages('rPRaat')\ndevtools::install_github('tsostarics/sosprosody')\n\n\nNow we’ll load the packages we’ll be using.\n\n\nCode\nlibrary(dplyr)      # For joins\nlibrary(rPraat)     # Read functions for textgrids and pitch tiers\nlibrary(sosprosody) # Helpers for working with textgrids and pitch tiers\n\n# These two are part of any tidyverse installation\nlibrary(ggplot2)    # For plotting\nlibrary(purrr)      # For mapping functions"
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#piecewise-equal-pulses",
    "href": "posts/pulselabeling/pulse_labeling.html#piecewise-equal-pulses",
    "title": "Pulse Labeling",
    "section": "Piecewise equal pulses",
    "text": "Piecewise equal pulses\nThis is an example using the piecewise_interpolate_pulses function2 from sosprosody to get equally spaced pulses within each section.3 Here I’ll get 50 equally spaced pulses for each syllable in all of our words (which are all two syllables).\n\n\n\n\n\n\nTip\n\n\n\nAt the time of this writing, a warning will be thrown since reframe was added to dplyr to take over a deprecated functionality from summarize. I will fix this in the package at a later data after dplyr 1.1 is released. The warning can be ignored though.\n\n\n\n\nCode\n# Switch to using syllable tier instead\ntier_df <- tiers$syllable\n\n# Small post processing steps\ntier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\ntier_df$interval_i <- seq_len(nrow(tier_df))\n\nlabeled_df2 <- \n  left_join(pt_df, \n            tier_df, \n            join_by(file, \n                    timepoint >= interval_start, \n                    timepoint < interval_end))\n\nlabeled_df2 |> \n  dplyr::filter(label != \"\") |>  # Remove prenuclear material with blank label\n  # Get fifty equally spaced pulses by interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"interval_i\",\n                                           pulses_per_section = 50,\n                                           time_by = \"timepoint\",\n                                           .pitchval = \"hz\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint, y = hz, color= factor(interval_i), shape = interval_i)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = 'none') +\n  annotate(geom = \"text\",\n           x = c(.8, 1.1),\n           y = c(90, 90),\n           color = c('firebrick','dodgerblue4'),\n           label = c(\"Syl1\",\"Syl2\"),\n           size = 10) \n\n\n\n\n\nMoreover, piecewise_interpolate_pulses can be used to get a certain number of pulses per section. This allows you to upsample or downsample different parts of the utterance as needed (cf the above example upsampled across the board). Below, I’ll get 10 pulses for the first section and 40 pulses for the second.4\n\n\nCode\nlabeled_df2 |> \n  dplyr::filter(label != \"\") |>  # Remove prenuclear material with blank label\n  # Get different numbers of pulses by interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"interval_i\",\n                                           pulses_per_section = c('2' = 10,\n                                                                  '3' = 40),\n                                           time_by = \"timepoint\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint, y = hz, color= factor(interval_i))) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = 'none') +\n  annotate(geom = \"text\",\n           x = c(.8, 1.1),\n           y = c(90, 90),\n           color = c('firebrick','dodgerblue4'),\n           label = c(\"Syl1\",\"Syl2\"),\n           size = 10) \n\n\n\n\n\nAnd that’s all! If you’d like to see a bigger example of how it might be useful to label regions of a pitch contour or extract equally spaced samples, you can take a look at the plots on this poster. I’ve used this approach to extract less pulses from the prenuclear region of the utterance and more pulses from the nuclear region, then average multiple pitch contours across the extracted pulses."
  }
]