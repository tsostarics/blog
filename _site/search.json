[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Pulse Labeling\n\n\n\n\n\n\n\nR\n\n\nPraat\n\n\n\n\nThis post discusses using non-equi joins to label pitch pulses by an interval on a TextGrid.\n\n\n\n\n\n\nJan 25, 2023\n\n\nThomas Sostarics\n\n\n\n\n\n\n\n\nContrastable\n\n\n\n\n\n\n\nR pkg\n\n\n\n\nThis post gives an overview of an R package I’ve written. The contrastable package provides a tidy approach to contrast coding for regression analyses.\n\n\n\n\n\n\nJul 13, 2022\n\n\nThomas Sostarics\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/contrastable/index.html",
    "href": "posts/contrastable/index.html",
    "title": "Contrastable",
    "section": "",
    "text": "I’ve been working on a package called contrastable on and off for the past year or so. The package’s goal is to provide a tidy approach to setting factor contrasts for regression analysis. While this can be done with repeated contrasts<- calls, this workflow is tedious when working with multiple factors and especially error-prone when manually specifying contrast matrices to use. In this latter case, the user would need to be careful to specify the correct fractions in the correct order with the correct signs, which can be a lot to keep track of. These issues quickly become apparent when the number of factor levels is greater than 2. In this post I will:"
  },
  {
    "objectID": "posts/contrastable/index.html#contrasts-overview",
    "href": "posts/contrastable/index.html#contrasts-overview",
    "title": "Contrastable",
    "section": "Contrasts overview",
    "text": "Contrasts overview\nContrast coding refers to assigning numeric values to levels of a categorical variable for use in regression analyses. Depending on the numbers used, different comparisons can be made between the group means of a variable. These comparisons can correspond to particular null hypotheses that a researcher might have, and particular combinations of numbers can encode high-level questions like “Are there differences between levels when compared to a common reference level?” or “Does each level differ from the levels that came before it?” Critically, the contrasts used don’t impact the model fit but do impact the coefficient estimates that are used to make inferences about the data. For example, you might conclude that there’s an overall effect of some factor when in reality the effect (shown by the coefficient estimate) is an effect that only holds for one particular group!\nConsider an example where you have two groups of listeners where English is their native (L1) or non-native (L2) language. You might be interested in whether reading times are slower or faster in two different syntactic conditions, such as active vs passive constructions. Two possible research questions might be whether there’s an main effect of syntax on reading times on the one hand or whether there’s a simple effect such that reading times in the passive construction are only slower for L2 speakers.1 These are similar, but different, research questions and more importantly, the interpretation of one coefficient depends on how other variables are coded. Many researchers realize (or are starting to at least) that the default2 “0/1 contrasts” (aka treatment or dummy coding) will only give them the simple effect of structure, but if what you’re interested in is that main effect, then your statistics has not yet answered your question! To rectify this, researchers will opt for “the +.5/-.5 contrasts” to obtain main effects.\n\n\n\n\n\n\nWarning: Naming inconsistency\n\n\n\nThe name for this contrast scheme is not consistent, especially in the 2-level case where the values are +.5/-.5. I’ve seen it called sum coding, simple coding, effects coding, scaled sum coding, helmert coding, difference coding, contrast coding, sum-to-zero coding, and +.5/-.5 coding. See Brehm and Alday (2022) for concerns about transparent descriptions of contrast coding schemes.\n\n\nWhile researchers may differ on what they call +.5/-.5, for 2 levels the result is nonetheless the same. But, a researcher using “helmert coding” and a researcher using “scaled sum coding” for a factor with 3 or more levels will be using very different contrast matrices, and thus address very different research questions about the data. Let’s use some functions from contrastable to look at how these contrast matrices differ.\n\nlibrary(contrastable)\n\n\n2 levels3 levels5 levels\n\n\n\nhelmert_code(2) |> MASS::fractions()\n\n     [,1]\n[1,]  1/2\n[2,] -1/2\n\nscaled_sum_code(2) |> MASS::fractions()\n\n  [,1]\n1  1/2\n2 -1/2\n\n\n\n\n\nhelmert_code(3) |> MASS::fractions()\n\n     [,1] [,2]\n[1,]  2/3    0\n[2,] -1/3  1/2\n[3,] -1/3 -1/2\n\nscaled_sum_code(3) |> MASS::fractions()\n\n  [,1] [,2]\n1  2/3 -1/3\n2 -1/3  2/3\n3 -1/3 -1/3\n\n\n\n\n\nhelmert_code(5) |> MASS::fractions()\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\nscaled_sum_code(5) |> MASS::fractions()\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\nNote that I use the term scaled sum coding for the “pairwise comparisons with main effects” contrast scheme. I opt for this term for three reasons.\n\nFirst, I see sum coding used more frequently in statistics and econometrics to refer to +1/-1; this is also what contr.sum in R returns.\nSecond, the salient part of going from sum coding to scaled sum coding, especially in the 2-level case, is that there’s some kind of division or scaling operation involved; I frequently see people use contr.sum(2)/2, although importantly contr.sum(3)/3 does not yield the expected result.\nThird, “simple” coding is counterintuitive to me since we’re trying to avoid “simple effects;” “effects coding” and “contrast coding” are largely meaningless as all coding schemes will encode some kind of effect, and setting any contrast matrix is an instance of contrast coding.\n\nSo, for the researcher trying to remember “I need to use those contrasts where they’re divided to get the main effects”, it (to me) seems easy to reach for a tool where scaled is in the name and is clearly distinguished from sum coding. 3"
  },
  {
    "objectID": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "href": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "title": "Contrastable",
    "section": "Typical approach to contrast coding",
    "text": "Typical approach to contrast coding\nTypically when I see people in Linguistics set contrasts, they do something like the following, using the palmerpenguins dataset as an example.\n\n\nCode\nlibrary(dplyr)          # Data wrangling\nlibrary(purrr)          # Mapping functions\nlibrary(palmerpenguins) # Dataset\npenguins_with_contrasts <- penguins\n\n# Default treatment/dummy coding for a 2 and 3 level factor\ncontrasts(penguins_with_contrasts$sex)\n\n\n       male\nfemale    0\nmale      1\n\n\nCode\ncontrasts(penguins_with_contrasts$species)\n\n\n          Chinstrap Gentoo\nAdelie            0      0\nChinstrap         1      0\nGentoo            0      1\n\n\nCode\n# Easy enough for 2 levels, -contr.sum(2)/2 is also used a lot\ncontrasts(penguins_with_contrasts$sex) <- c(-.5, .5) \n\n# Not so fun for three levels!\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 2/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\n\n\nThe chance of making a mistake increases when including more and more categorical variables. Catching these mistakes can be very difficult, in part because this workflow erases the labels in the regression output. This means you have to keep track of what 1 and 2 in the regression coefficients correspond to.\n\n\n\n\n\n\nNote: Column/Comparison/Coefficient names\n\n\n\nWhile the dimnames argument can be used to set the labels, anecdotally I rarely see people use this in their analyses when perusing code on the osf. Winter (2019, 127) notes that “Using the ‘1’ after the predictor name is a notational convention for representing the slopes of sum-coded predictors in R” but this is slightly incorrect; in the absence of dimnames being set, R will use the numeric indices of the contrast matrix’s columns (no matter what the scheme is).\n\n\nBelow, the two sets of coefficients represent pairwise comparisons to the Adelie baseline, but the intercepts differ due to how the contrasts are set, with the first using treatment coding and the second using scaled sum coding. I’ll start with a case that only considers the categorical variable, but will include an additional continuous independent variable later on.\n\n\nCode\n# Compare the default treatment coding with the penguins dataset\n# with the contrasts we specified in penguins_with_contrasts\ntreatment_coefs <- coef(lm(bill_length_mm ~ species,\n                           data = penguins))    \nscaledsum_coefs <- coef(lm(bill_length_mm ~ species, \n                           data = penguins_with_contrasts)) \n\n# I'm using list() to print and caption results side by side, purely aesthetic\nlist(\"(Default) Treatment Coding\" = treatment_coefs,\n     \"(Manual) Scaled Sum Coding\" = scaledsum_coefs)\n\n\n$`(Default) Treatment Coding`\n     (Intercept) speciesChinstrap    speciesGentoo \n       38.791391        10.042433         8.713487 \n\n$`(Manual) Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nThe model coefficients for the scaled sum coding shows the same pairwise comparisons as the model using treatment coding, but the intercepts differ. We can check what they correspond to manually:\n\n\nCode\ngroup_means <- \n  penguins |>\n  dplyr::group_by(species) |> \n  dplyr::summarize(mean_length = mean(bill_length_mm, na.rm = TRUE)) |> \n  purrr::pluck('mean_length') |> \n  `names<-`(c('Adelie', 'Chinstrap', 'Gentoo'))\n\nlist(\"Group means\"= group_means,\n     \"Grand mean\" = mean(group_means))\n\n\n$`Group means`\n   Adelie Chinstrap    Gentoo \n 38.79139  48.83382  47.50488 \n\n$`Grand mean`\n[1] 45.04336\n\n\nSo the intercept for the treatment coded model is the mean of the Adelie group while the scaled sum coded model is the grand mean, or the mean of group means. But, typing in the scaled sum contrast matrix was a bit obnoxious with all the -1/3 we typed. If we had made a slight mistake while typing the matrix out, what would have happened to our model? Would our coefficients reflect the averages and differences we were expecting? As an example, let’s see what happens when we change a 2/3 to 1/3:\n\n\nCode\n# What if we accidentally typed 1/3 instead of 2/3?\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 1/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\nmistake_coefs <- coef(lm(bill_length_mm ~ species, \n                         data = penguins_with_contrasts))\n\nlist(\"(Current) Mistaken Scaled Sum Coding:\" = mistake_coefs,\n     \"(Previous) Correct Scaled Sum Coding:\" = scaledsum_coefs)\n\n\n$`(Current) Mistaken Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`(Previous) Correct Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nHere we can see that the intercept and the value for species1 have increased in magnitude. In particular, the new reported effect of species1 is much larger than it previously was. If we stopped at this point, we would conclude that the difference in bill length between the Chinstrap and Adelie groups is a whopping 15mm (remember we originally calculated it to be about 10). If we were interested in whether there was a positive or negative difference that was significant or not, we’d still make that conclusion, but any claims about the magnitude of the effect would be misguided. This problem opens up a related question though: What does this new inflated-in-magitude coefficient estimate represent?\n\nDiagnosing our mistake\nTo check what these numbers correspond to, we have to check the hypothesis matrix that corresponds to our contrast matrix. The process of obtaining the hypothesis matrix has been referred to as finding the generalized inverse of the contrast matrix (see Schad et al. 2020 for details).\n\n\nCode\nmatrix(c(1, 1, 1,         # Add a column of 1s for the intercept\n         -1/3, 1/3, -1/3,\n         -1/3, -1/3, 2/3),\n       nrow = 3,\n       dimnames = list(NULL, c('Intercept', 'species1', 'species2'))) |> \n  t() |> \n  solve() |> \n  MASS::fractions() # This function just shows numbers as fractions\n\n\n     Intercept species1 species2\n[1,]  1/6      -3/2       -1    \n[2,]  1/2       3/2        0    \n[3,]  1/3         0        1    \n\n\nHere the intercept is represented by the weighted sum of each group mean, where the weights are shown in the intercept column. In most cases, the intercept should reflect the grand mean, or the mean of the group means, and so would usually have equal weights (i.e., 1/3 here) for the levels. In this case, we see the fractional weights are not the same. We can verify this by calculating the weighted mean ourselves:\n\n\nCode\nlist(\"Grand Mean\" = mean(group_means),\n     \"Weighted mean\" = weighted.mean(group_means, c(1/6, 1/2, 1/3)))\n\n\n$`Grand Mean`\n[1] 45.04336\n\n$`Weighted mean`\n[1] 46.7171\n\n\nSimilarly, the coefficient for species1 shows the difference between the group means of levels 1 and 2 (i.e., mean of Chinstrap - mean of Adelie) but times a factor of 3/2. Crucially, if our goal is to evaluate the difference between the means of these two levels, then our mistake in coding the hypothesis matrix will give us a larger estimate (~15 vs 10). Consider a similar setup where the larger estimate was 5 instead of 0; if we were relying on null hypothesis testing it’s possible we’d get a significant effect when really we shouldn’t have.\n\n\nCode\nlist(\"Mistaken Scaled Sum Coding\" = mistake_coefs,\n     \"Correct Scaled Sum Coding\" = scaledsum_coefs,\n     \"Computed Chinstrap-Adelie Difference with 3/2 scaling\" = \n       (3/2 * group_means[['Chinstrap']]) - (3/2 * group_means[['Adelie']]),\n     \"Actual Chinstrap-Adelie Difference\" = \n       group_means[['Chinstrap']] - group_means[['Adelie']])\n\n\n$`Mistaken Scaled Sum Coding`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`Correct Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n$`Computed Chinstrap-Adelie Difference with 3/2 scaling`\n[1] 15.06365\n\n$`Actual Chinstrap-Adelie Difference`\n[1] 10.04243\n\n\nPoint being: we made an honest mistake of typing 1/3 instead of 2/3 but this had ramifications for the coefficients in our model output that we use to make inferences. In practice, because we did the multiple contrasts<- calls, we would likely assume that what we did was correct in the absence of any errors."
  },
  {
    "objectID": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "href": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "title": "Contrastable",
    "section": "Tidy approach to contrasts",
    "text": "Tidy approach to contrasts\nHere I’ll show a different approach using the contrastable package. This package takes a tidy approach to take care of the overhead of labels and reference levels involved when using common contrast coding schemes. Specifically, this package provides a series of functions that use a special formula implementation that assigns specific meanings to each operator. The left hand side of the formula is the factor column whose contrasts you want to change. The right hand side consists of (at minimum) a function to generate contrast matrices such as contr.treatment or treatment_code. Additional operators provide extra optional functionality:\n\n+ x: Set reference level to level x\n* x: Set intercept to be the mean of x\n- 3:4: For polynomial contrasts only, drop trends 3 and 4\n| c(\"A-B\", \"A-C\"): Set the comparison labels to A-B and A-C (must be the last operator if used)\n\nRecall that in many cases researchers want pairwise comparisons while retaining main effects, and so the choice of reference level for the comparisons is very important. By default, R uses the first level alphabetically as the reference level, but sometimes we want to change this manually ourselves. Here’s an example where we set the sex and species factors to the two contrast schemes we manually set before. The set_contrasts function will show a message if it detects additional factor variables in the dataframe that the user did not provide contrasts for.\n\n\nCode\n# library(contrastable) was loaded earlier\npenguins_df <- \n  penguins |> \n  set_contrasts(sex ~ scaled_sum_code + \"male\", # Set reference level with +\n                species ~ scaled_sum_code + 'Adelie') \n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\nCode\ncontrasts(penguins_df$species) |> MASS::fractions()\n\n\n          Chinstrap Gentoo\nAdelie    -1/3      -1/3  \nChinstrap  2/3      -1/3  \nGentoo    -1/3       2/3  \n\n\nCode\ncontrasts(penguins_df$sex) |> MASS::fractions()\n\n\n       female\nfemale  1/2  \nmale   -1/2  \n\n\npenguins_df now has its contrasts set, and we can run our model as usual. Note that we didn’t have to type out any matrices ourselves, but we got the correct contrasts that we needed.\n\n\nCode\ncoef(lm(bill_length_mm ~ species + bill_depth_mm, data = penguins_df))\n\n\n     (Intercept) speciesChinstrap    speciesGentoo    bill_depth_mm \n       20.997115         9.938955        13.403279         1.394011 \n\n\nIf we wanted to change the labels to better reflect the comparisons being made, we could do that in the formula too with the | operator.\n\n\nCode\npenguins_df <- \n  penguins_df |> \n  set_contrasts(species ~ scaled_sum_code + 'Adelie' | \n                  c('Chinstrap-Ad', 'Gentoo-Ad'))\n\ncoef(lm(bill_length_mm ~ species, data = penguins_df))\n\n\n        (Intercept) speciesChinstrap-Ad    speciesGentoo-Ad \n          45.043364           10.042433            8.713487 \n\n\n\nAdditional functions\nTypically when I use this package in my analyses the set_contrasts function is all I really need, but there are other functions that follow the same syntax that provide other information. To avoid retyping things, I’ll usually keep the contrasts in a list assigned to a separate variable and pass that to functions.\nThe glimpse_contrasts function can show information about the factors in a dataset along with the contrast schemes that have been assigned to each factor.\n\n\nCode\nmy_contrasts <- \n  list(\n    sex ~ scaled_sum_code + 'female',\n    species ~ helmert_code\n  )\n\nglimpse_contrasts(penguins_df, my_contrasts) |> gt::gt()\n\n\n\n\n\n\n  \n  \n    \n      factor\n      n_levels\n      level_names\n      scheme\n      reference\n      intercept\n      orthogonal\n      centered\n      dropped_trends\n      explicitly_set\n    \n  \n  \n    sex\n2\nfemale, male\nscaled_sum_code\nfemale\ngrand mean\nNA\nTRUE\nNA\nTRUE\n    species\n3\nAdelie, Chinstrap, Gentoo\nhelmert_code\nGentoo\ngrand mean\nTRUE\nTRUE\nNA\nTRUE\n    island\n3\nBiscoe, Dream, Torgersen\ncontr.treatment\nBiscoe\nmean(Biscoe)\nFALSE\nFALSE\nNA\nFALSE\n  \n  \n  \n\n\n\n\nThe enlist_contrasts function does the same thing as set_contrasts, but returns a list of contrast matrices that can be used in the contrasts argument of some model-fitting functions.4 It also provides an easy way to show the contrast matrices in an appendix or supplementary material.\n\n\nCode\nenlist_contrasts(penguins_df, my_contrasts) |> purrr::map(MASS::fractions)\n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\n$sex\n       male\nfemale -1/2\nmale    1/2\n\n$species\n          >Adelie >Chinstrap\nAdelie     2/3       0      \nChinstrap -1/3     1/2      \nGentoo    -1/3    -1/2      \n\n\n\n\nAvailable contrast schemes\nHere are the different contrast functions this package currently provides.\n\nTreatmentSumScaled SumHelmertReverse HelmertForward DifferenceBackward DifferenceOrthogonal PolynomialsRaw Polynomials\n\n\n\n\nCode\n# = contr.treatment\ntreatment_code(5) |> MASS::fractions()\n\n\n  2 3 4 5\n1 0 0 0 0\n2 1 0 0 0\n3 0 1 0 0\n4 0 0 1 0\n5 0 0 0 1\n\n\n\n\n\n\nCode\n# = contr.sum\nsum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  1    0    0    0  \n2  0    1    0    0  \n3  0    0    1    0  \n4  0    0    0    1  \n5 -1   -1   -1   -1  \n\n\n\n\n\n\nCode\n# = contr.sum\nscaled_sum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\n\nCode\n# NOT = contr.helmert, which is unscaled\nhelmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\n\n\n\n\n\nCode\nreverse_helmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -1/2 -1/3 -1/4 -1/5\n[2,]  1/2 -1/3 -1/4 -1/5\n[3,]    0  2/3 -1/4 -1/5\n[4,]    0    0  3/4 -1/5\n[5,]    0    0    0  4/5\n\n\n\n\n\n\nCode\nforward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5  3/5  2/5  1/5\n[2,] -1/5  3/5  2/5  1/5\n[3,] -1/5 -2/5  2/5  1/5\n[4,] -1/5 -2/5 -3/5  1/5\n[5,] -1/5 -2/5 -3/5 -4/5\n\n\n\n\n\n\nCode\nbackward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -4/5 -3/5 -2/5 -1/5\n[2,]  1/5 -3/5 -2/5 -1/5\n[3,]  1/5  2/5 -2/5 -1/5\n[4,]  1/5  2/5  3/5 -1/5\n[5,]  1/5  2/5  3/5  4/5\n\n\n\n\n\n\nCode\n# = contr.poly, poly(1:n, degree = n-1, raw = FALSE)\north_polynomial_code(5) |> MASS::fractions()\n\n\n     .L                .Q                .C                ^4               \n[1,]          -265/419          929/1738  -2026009/6406803        4018/33617\n[2,]  -2026009/6406803         -809/3027           191/302    -246481/515552\n[3,]                 0       -6263/11717                 0         1042/1453\n[4,] 12484830/39480499         -809/3027          -265/419    -246481/515552\n[5,]           191/302          929/1738 10458821/33073696        4018/33617\n\n\n\n\n\n\nCode\n# = poly(1:n, degree = n-1, raw = TRUE)\nraw_polynomial_code(5) |> MASS::fractions()\n\n\n     1   2   3   4  \n[1,]   1   1   1   1\n[2,]   2   4   8  16\n[3,]   3   9  27  81\n[4,]   4  16  64 256\n[5,]   5  25 125 625"
  },
  {
    "objectID": "posts/contrastable/index.html#other-packages-and-resources",
    "href": "posts/contrastable/index.html#other-packages-and-resources",
    "title": "Contrastable",
    "section": "Other packages and resources",
    "text": "Other packages and resources\nThis package is not the first package made for contrast coding, though to my knowledge it is the first to take a “tidy” approach to it.\nThe hypr package (Rabe et al. 2020) takes a different approach, where the focus is on considering the hypothesis matrix and declaring specifically which comparisons you want to make, then the package can provide a corresponding matrix. I like hypr a lot actually, but I find it a bit tedious when I know what the contrast matrix should look like but I have to type out the comparisons; still better than matrix calls though.\nThe emmeans package (Lenth 2022) is extremely useful for making pairwise comparisons, but is capable of a lot more as well. You can see its vignette on contrasts here.\nThe multcomp package (Hothorn, Bretz, and Westfall 2008) is useful for simultaneous inference, which seeks to extend workflows for multiple comparisons.\nI haven’t used the contrasts package (O’Callaghan 2021) very much, but judging from its vignette here it seems like it extends the rms package’s contrast function (Harrell Jr 2022). It seems useful for calculating different comparisons after a model is run, but its usage isn’t very transparent to me on first glance.\nWhile not a package, this page from UCLA pops up a lot when people discuss contrast coding. It’s very useful, and I used it as a starting point for implementing different contrast functions. However, I will note that I don’t follow its naming conventions.\n\n\nCode\nsessionInfo()\n\n\nR version 4.2.2 (2022-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 22621)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] palmerpenguins_0.1.1 purrr_1.0.0          dplyr_1.1.0         \n[4] contrastable_0.1.0  \n\nloaded via a namespace (and not attached):\n [1] pillar_1.8.1      compiler_4.2.2    tools_4.2.2       digest_0.6.31    \n [5] jsonlite_1.8.4    evaluate_0.20     lifecycle_1.0.3   tibble_3.1.8     \n [9] gtable_0.3.1      pkgconfig_2.0.3   rlang_1.0.6       cli_3.5.0        \n[13] rstudioapi_0.14   yaml_2.3.7        xfun_0.37         fastmap_1.1.0    \n[17] withr_2.5.0       stringr_1.5.0     knitr_1.42        sass_0.4.5       \n[21] generics_0.1.3    vctrs_0.5.2       htmlwidgets_1.6.1 grid_4.2.2       \n[25] tidyselect_1.2.0  glue_1.6.2        R6_2.5.1          fansi_1.0.3      \n[29] rmarkdown_2.20    ggplot2_3.4.0     magrittr_2.0.3    scales_1.2.1     \n[33] htmltools_0.5.4   MASS_7.3-58.1     gt_0.8.0          colorspace_2.0-3 \n[37] utf8_1.2.2        stringi_1.7.8     munsell_0.5.0     crayon_1.5.2"
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html",
    "href": "posts/pulselabeling/pulse_labeling.html",
    "title": "Pulse Labeling",
    "section": "",
    "text": "A colleague of mine recently asked for help with a bit of a tricky problem. Pitch contours, when extracted from an acoustic signal, come in the form of a time series of discretized pulses: a (time, frequency) point. However, these contours occur over varying parts of the spoken sentence. In other words, the rises and falls in pitch occur over different words, syllables, and phones– all of which have varying durations. If we take a pitch contour over a single word from the productions of many speakers, then time normalize them, we don’t have access to the relative durations and landmarks of the syllables that make up the token. For instance, if two speakers rise from 110Hz to 220Hz over one syllable, this rise will be much steeper if the first syllable is 30% of the time normalized duration compared to if the first syllable is 60% of the time normalized duration. The problem then becomes two related problems:\nAs it happens, this problem becomes fairly straightforward when using non-equi joins. These are joins (left, right, etc.) that match not merely on equivalence matching, but when more complex logical operations need to be used. In our case, we want to merge information about the pulses and their timestamps with information about the syllable boundary timestamps. We can accomplish this by joining two dataframes based on whether the pulse timestamp is between the start and end timestamps of a particular interval.\nIn this post, I’ll show how this can be accomplished in R using the new non-equi join functionality added to {dplyr} version 1.1.1 In the process, I’ll also show off some tools from the {rPraat} package and the {sosprosody} package, which I am developing to support the analyses and data processing for my dissertation work. These packages provide some useful functionality for working with PitchTier and TextGrid objects from Praat. However, this functionality can also be accomplished through any non-equi join implementation. I’m familiar with the {fuzzyjoin} package, and this post provides some additional options."
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#required-packages",
    "href": "posts/pulselabeling/pulse_labeling.html#required-packages",
    "title": "Pulse Labeling",
    "section": "Required packages",
    "text": "Required packages\nSee below code block for installation of the most relevant packages. {dplyr} must be version 1.1/the development version (as of this writing) to allow for non-equi/fuzzy joins, and so is not (yet) part of a typical installation of tidyverse.2 Refer to below code block for installation.\n\n\nCode\n# devtools or remotes can be used to install from github\ndevtools::install_github(\"tidyverse/dplyr\")\ninstall.packages('rPRaat')\ndevtools::install_github('tsostarics/sosprosody')\n\n\nNow we’ll load the packages we’ll be using.\n\n\nCode\nlibrary(dplyr)      # For joins\nlibrary(rPraat)     # Read functions for textgrids and pitch tiers\nlibrary(sosprosody) # Helpers for working with textgrids and pitch tiers\n\n# These two are part of any tidyverse installation\nlibrary(ggplot2)    # For plotting\nlibrary(purrr)      # For mapping functions"
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#piecewise-equal-pulses",
    "href": "posts/pulselabeling/pulse_labeling.html#piecewise-equal-pulses",
    "title": "Pulse Labeling",
    "section": "Piecewise equal pulses",
    "text": "Piecewise equal pulses\nThis is an example using the piecewise_interpolate_pulses function3 from sosprosody to get equally spaced pulses within each section.4 Here I’ll get 50 equally spaced pulses for each syllable in all of our words (which are all two syllables).\n\n\nCode\nsyllable_labeled_df <- \n  label_pitch_pulses(tier = 'syllable') |> \n  dplyr::filter(interval_i != 1) |> \n  rename(syllable = label)\n\nsyllable_labeled_df |> \n  # Get fifty equally spaced pulses for each interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = 50,\n                                           time_by = \"timepoint\",\n                                           .pitchval = \"hz\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint, y = hz, color= syllable, shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~file) +\n  coord_fixed(1/50)\n\n\n\n\n\nMoreover, piecewise_interpolate_pulses can be used to get a certain number of pulses per section. This allows you to upsample or downsample different parts of the utterance as needed (cf the above example upsampled across the board). Below, I’ll get 10 pulses for the first section and 40 pulses for the second.5\n\n\nCode\nsyllable_labeled_df |> \n  # Get different numbers of pulses by interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"timepoint\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top')\n\n\n\n\n\nIn the above plot, we can tell that at least one of the files have a pitch contour that starts a bit later than the others given the raw time on the x axis. This arises due to the slightly longer prenuclear material present in that utterance (the other two files were resynthesized from the same source file). We can time normalize these files such that the first syllable from each contour is directly comparable, i.e., they’ll all start at 0 and end at 1. And we can do that separately for the second syllable too. It’s more typical to time normalize by the duration of an entire word or utterance, but we’ll work with a more narrow case of time normalizing within each syllable. We address this problem with with much of the tools we’ve already used so far. Below I use the time_normalize function from sosprosody, which is a convenience wrapper that does the subtraction and division operations for time normalizing.6\n\n\nCode\n# Time normalize by syllable\nsyllable_labeled_df |> \n  group_by(file, interval_i) |> \n  sosprosody::time_normalize(.to = 'time_norm') |> \n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"time_norm\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = time_norm,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~syllable) +\n  coord_fixed(1/50)\n\n\n\n\n\nAnd that’s all! If you’d like to see a bigger example of how it might be useful to label regions of a pitch contour or extract equally spaced samples, you can take a look at the plots on this poster. I’ve used this approach to extract less pulses from the prenuclear region of the utterance and more pulses from the nuclear region, then average multiple pitch contours across the extracted pulses.\n\n\nCode\nsessionInfo()\n\n\nR version 4.2.2 (2022-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 22621)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] purrr_1.0.0           ggplot2_3.4.0         sosprosody_0.0.0.9000\n[4] rPraat_1.3.2-1        dplyr_1.1.0          \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9        pillar_1.8.1      compiler_4.2.2    tools_4.2.2      \n [5] bit_4.0.5         digest_0.6.31     jsonlite_1.8.4    evaluate_0.20    \n [9] lifecycle_1.0.3   tibble_3.1.8      gtable_0.3.1      pkgconfig_2.0.3  \n[13] rlang_1.0.6       cli_3.5.0         rstudioapi_0.14   parallel_4.2.2   \n[17] yaml_2.3.7        xfun_0.37         fastmap_1.1.0     withr_2.5.0      \n[21] knitr_1.42        generics_0.1.3    vctrs_0.5.2       htmlwidgets_1.6.1\n[25] hms_1.1.2         bit64_4.0.5       grid_4.2.2        tidyselect_1.2.0 \n[29] glue_1.6.2        R6_2.5.1          fansi_1.0.3       vroom_1.6.1      \n[33] rmarkdown_2.20    farver_2.1.1      tzdb_0.3.0        readr_2.1.3      \n[37] magrittr_2.0.3    ellipsis_0.3.2    scales_1.2.1      htmltools_0.5.4  \n[41] colorspace_2.0-3  labeling_0.4.2    utf8_1.2.2        munsell_0.5.0    \n[45] crayon_1.5.2"
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#example-with-one-file",
    "href": "posts/pulselabeling/pulse_labeling.html#example-with-one-file",
    "title": "Pulse Labeling",
    "section": "Example with one file",
    "text": "Example with one file\nOur goal: Associate each pitch pulse with an interval on a tier from a TextGrid.\nThe approach: Non-equi joins. Given a dataframe for the pitch pulses and a dataframe for a tier from a TextGrid, when a pitch pulse timepoint lies between interval_start and interval_end, join interval_start, interval_end, and the interval label.\nFirst we’ll load our files, located in the Files directory. Because I’m working with just one example right now, I’ll write the strings out directly.\n\n\nCode\npt_file <- \"Files/branning_1.PitchTier\"\ntg_file <- \"Files/branning_1.TextGrid\"\n\n\nNow we’ll read the PitchTier and TextGrid files into R using rPraat. The sosprosody package provides new print methods for PitchTier and TextGrid objects, which can also be seen below (these would be displayed in the console).\n\n\nCode\n# The default encoding is UTF-8, but there's a common \n# case where Praat encodes files with UTF-16LE\npt <- rPraat::pt.read(pt_file, encoding= \"auto\")\ntg <- rPraat::tg.read(tg_file, encoding = \"auto\")\n\n\n\n\n\n\nbranning_1.PitchTier: 108 total pitch pulses.\n109|                                                                           |\n   |                                             OOO                           |\n   |                                          OOO   OO                         |\n   |                                      OOOO        OO                       |\n   |                                  OOOO              O                      |\n   |                                OO                   OO                    |\n   |      OOOOOOOOOOOOOOOOOOOOOOOOOO                       OOO                 |\n   |                                                          OOO              |\n   |                                                             OOOO          |\n 65|                                                                 OOO       |\n   0                                                                        1.49 \n\n\nbranning_1.TextGrid\n[                words: 4/6 labeled intervals from 0 to 1.49                   ]\n[                phones: 15/17 labeled intervals from 0 to 1.49                ]\n[                nuclear: 1/3 labeled intervals from 0 to 1.49                 ]\n[                syllable: 2/4 labeled intervals from 0 to 1.49                ] \n\n\n\n\nNow that we have access to our PitchTier and TextGrid, we can convert them into data frame representations, again using sosprosody. We’ll limit our scope right now to just the phones tier.\n\n\nCode\n# TextGrid as a a dataframe\ntiers <- sosprosody::textgrid_to_dataframes(tg) # List of dfs for each tier\ntier_df <- tiers$phones # Extract a single tier\n\n# Small post processing steps\ntier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\ntier_df$interval_i <- seq_len(nrow(tier_df)) # Assign numeric indices\nhead(tier_df)\n\n\n        file interval_start interval_end label interval_i\n1 branning_1      0.0000000    0.1312844                1\n2 branning_1      0.1312844    0.2200000     m          2\n3 branning_1      0.2200000    0.2500000     ɑ          3\n4 branning_1      0.2500000    0.3800000     ʎ          4\n5 branning_1      0.3800000    0.4297910     i          5\n6 branning_1      0.4297910    0.4910510     z          6\n\n\nCode\n# Pitchtier as a dataframe, we don't need to calculate semitones and ERBs\npt_df <- sosprosody::pitchtier_to_dataframe(pt, \n                                            add_semitones = FALSE,\n                                            add_erbs = FALSE)\nhead(pt_df)\n\n\n        file timepoint       hz\n1 branning_1 0.1514512 89.57813\n2 branning_1 0.1614512 89.96063\n3 branning_1 0.1714512 89.98904\n4 branning_1 0.1814512 89.94582\n5 branning_1 0.1914512 89.89566\n6 branning_1 0.2014512 89.87433\n\n\nNext we’re going to use the new non-equi join functionality from dplyr. We want to match up the file in tier_df with the correct file in pt_df, then check for when the pulse timepoint (i.e., pt_df$timepoint) lies after interval_start and before interval_end. The choice of >= and < is largely arbitrary, you could do > and <= and get the same results unless you have pitch points that lie exactly on the boundary.\n\n\nCode\nlabeled_df <- \n  dplyr::left_join(pt_df, \n                   tier_df, \n                   join_by(file, \n                           timepoint >= interval_start, \n                           timepoint < interval_end))\n\nhead(labeled_df)\n\n\n        file timepoint       hz interval_start interval_end label interval_i\n1 branning_1 0.1514512 89.57813      0.1312844         0.22     m          2\n2 branning_1 0.1614512 89.96063      0.1312844         0.22     m          2\n3 branning_1 0.1714512 89.98904      0.1312844         0.22     m          2\n4 branning_1 0.1814512 89.94582      0.1312844         0.22     m          2\n5 branning_1 0.1914512 89.89566      0.1312844         0.22     m          2\n6 branning_1 0.2014512 89.87433      0.1312844         0.22     m          2\n\n\nTo check our work, let’s plot the pitch track to see what our result is like. Remember, we wanted to associate each pulse with the interval it appears in.\n\n\nCode\nlabeled_df |> \n  ggplot(aes(x = timepoint, y = hz, color = label, group = interval_i)) +\n  geom_line() +\n  geom_point() +\n  theme_bw(base_size = 14) +\n  # Add labels since there's a lot of colors\n  geom_label(data = summarize(group_by(labeled_df, label, interval_i),\n                              timepoint = median(timepoint),\n                              hz = median(hz) - 3),\n             aes(label = label)) +\n  theme(legend.position = 'none')\n\n\n\n\n\nLooks great! Now we can adapt this same basic workflow of loading our Praat objects, converting to dataframes, and doing a non-equi join and apply it to all the files in a directory. Note that if you extracted F0 measurements using a method other than exporting PitchTier files from Praat, then you can still do all the same steps above but just omit the part where you read in the PitchTier files. Ultimately, all we’re looking for is a dataframe that says what file(s) we have, what the pulse timepoints are, and what the frequency values at those timepoints are; how we get there doesn’t really matter."
  },
  {
    "objectID": "posts/pulselabeling/pulse_labeling.html#example-with-multiple-files",
    "href": "posts/pulselabeling/pulse_labeling.html#example-with-multiple-files",
    "title": "Pulse Labeling",
    "section": "Example with multiple files",
    "text": "Example with multiple files\nHere’s a pretty basic wrapper that encapsulates all of the previous steps into one function and operates over all the files in given directories containing TextGrids and PitchTiers.\n\n\n\n\n\n\nTip\n\n\n\nIf I were to do this for a larger set of files, I would probably split this up into two parts where I first load all the files then join them together. The reason being that if there’s an issue with joining the files in the below function, I would have to reload all the files again just to try the join again. Right now I’m only working with three files, so it doesn’t matter too much.\n\n\n\n\nCode\nlabel_pitch_pulses <- function(textgrid_dir = \"Files\", \n                               pitchtier_dir = \"Files\", \n                               tier = 'phones') {\n  # Note: This will fail if each textgrid does not have a corresponding\n  #       pitch tier file in the pitchtier directory\n  textgrids <- list.files(textgrid_dir, \n                          pattern = \".TextGrid$\",\n                          full.names = TRUE)\n  pitchtiers <- gsub(\".TextGrid$\", \".PitchTier\", textgrids, perl = TRUE)\n  \n  tg_dfs <- \n    map_dfr(textgrids,\n            \\(tg_path) {\n              tg <- rPraat::tg.read(tg_path, encoding = \"auto\")\n              tiers <- sosprosody::textgrid_to_dataframes(tg)\n              tier_df <- tiers[[tier]] \n              \n              # Small post processing steps\n              tier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\n              tier_df$interval_i <- seq_len(nrow(tier_df))\n              \n              tier_df\n            })\n  \n  pt_dfs <- \n    map_dfr(pitchtiers,\n            \\(pt_path) {\n              pt <- rPraat::pt.read(pt_path, encoding= \"auto\")\n              pt_df <- \n                sosprosody::pitchtier_to_dataframe(pt, \n                                                   add_semitones = FALSE,\n                                                   add_erbs = FALSE)\n              \n              pt_df\n            })\n  \n  # Execute the join\n  left_join(pt_dfs, \n            tg_dfs, \n            join_by(file, \n                    timepoint >= interval_start, \n                    timepoint < interval_end))\n  \n}\n\n\nAnd now the helper can be used to process all of our files; we’ll use it again later when we start working with syllables instead of phones.\n\n\nCode\nphone_labeled_df <- label_pitch_pulses()\n\n\nAs before, we can plot the pitch contours for each of our files to check our work.\n\n\nCode\nphone_labeled_df |> \n  ggplot(aes(x = timepoint, y = hz, group = interval_i, color = label)) +\n  geom_line() +\n  geom_point(size = .5) +\n  facet_wrap(~file) +\n  theme_bw(base_size = 14) +\n  geom_text(data = summarize(group_by(phone_labeled_df, file, label, interval_i),\n                             timepoint = median(timepoint),\n                             hz = median(hz) - 4),\n            aes(label = label)) +\n  theme(legend.position = 'none') +\n  coord_fixed(1/50)\n\n\n\n\n\nNext I’ll show an example of how this might be useful beyond just labeling and coloring our pitch contours by interval."
  },
  {
    "objectID": "posts/pulselabeling/index.html",
    "href": "posts/pulselabeling/index.html",
    "title": "Pulse Labeling",
    "section": "",
    "text": "A colleague of mine recently asked for help with a bit of a tricky problem. Pitch contours, when extracted from an acoustic signal, come in the form of a time series of discretized pulses: a (time, frequency) point. However, these contours occur over varying parts of the spoken sentence. In other words, the rises and falls in pitch occur over different words, syllables, and phones– all of which have varying durations. If we take a pitch contour over a single word from the productions of many speakers, then time normalize them, we don’t have access to the relative durations and landmarks of the syllables that make up the token. For instance, if two speakers rise from 110Hz to 220Hz over one syllable, this rise will be much steeper if the first syllable is 30% of the time normalized duration compared to if the first syllable is 60% of the time normalized duration. The problem then becomes two related problems:\nAs it happens, this problem becomes fairly straightforward when using non-equi joins. These are joins (left, right, etc.) that match not merely on equivalence matching, but when more complex logical operations need to be used. In our case, we want to merge information about the pulses and their timestamps with information about the syllable boundary timestamps. We can accomplish this by joining two dataframes based on whether the pulse timestamp is between the start and end timestamps of a particular interval.\nIn this post, I’ll show how this can be accomplished in R using the new non-equi join functionality added to {dplyr} version 1.1.1 In the process, I’ll also show off some tools from the {rPraat} package and the {sosprosody} package, which I am developing to support the analyses and data processing for my dissertation work. These packages provide some useful functionality for working with PitchTier and TextGrid objects from Praat. However, this functionality can also be accomplished through any non-equi join implementation. I’m familiar with the {fuzzyjoin} package, and this post provides some additional options."
  },
  {
    "objectID": "posts/pulselabeling/index.html#required-packages",
    "href": "posts/pulselabeling/index.html#required-packages",
    "title": "Pulse Labeling",
    "section": "Required packages",
    "text": "Required packages\nSee below code block for installation of the most relevant packages. {dplyr} must be version 1.1/the development version (as of this writing) to allow for non-equi/fuzzy joins, and so is not (yet) part of a typical installation of tidyverse.2 Refer to below code block for installation.\n\n\nCode\n# devtools or remotes can be used to install from github\ndevtools::install_github(\"tidyverse/dplyr\")\ninstall.packages('rPRaat')\ndevtools::install_github('tsostarics/sosprosody')\n\n\nNow we’ll load the packages we’ll be using.\n\n\nCode\nlibrary(dplyr)      # For joins\nlibrary(rPraat)     # Read functions for textgrids and pitch tiers\nlibrary(sosprosody) # Helpers for working with textgrids and pitch tiers\n\n# These two are part of any tidyverse installation\nlibrary(ggplot2)    # For plotting\nlibrary(purrr)      # For mapping functions"
  },
  {
    "objectID": "posts/pulselabeling/index.html#example-with-one-file",
    "href": "posts/pulselabeling/index.html#example-with-one-file",
    "title": "Pulse Labeling",
    "section": "Example with one file",
    "text": "Example with one file\nOur goal: Associate each pitch pulse with an interval on a tier from a TextGrid.\nThe approach: Non-equi joins. Given a dataframe for the pitch pulses and a dataframe for a tier from a TextGrid, when a pitch pulse timepoint lies between interval_start and interval_end, join interval_start, interval_end, and the interval label.\nFirst we’ll load our files, located in the Files directory. Because I’m working with just one example right now, I’ll write the strings out directly.\n\n\nCode\npt_file <- \"Files/branning_1.PitchTier\"\ntg_file <- \"Files/branning_1.TextGrid\"\n\n\nNow we’ll read the PitchTier and TextGrid files into R using rPraat. The sosprosody package provides new print methods for PitchTier and TextGrid objects, which can also be seen below (these would be displayed in the console).\n\n\nCode\n# The default encoding is UTF-8, but there's a common \n# case where Praat encodes files with UTF-16LE\npt <- rPraat::pt.read(pt_file, encoding= \"auto\")\ntg <- rPraat::tg.read(tg_file, encoding = \"auto\")\n\n\n\n\n\n\nbranning_1.PitchTier: 108 total pitch pulses.\n109|                                                                           |\n   |                                             OOO                           |\n   |                                          OOO   OO                         |\n   |                                      OOOO        OO                       |\n   |                                  OOOO              O                      |\n   |                                OO                   OO                    |\n   |      OOOOOOOOOOOOOOOOOOOOOOOOOO                       OOO                 |\n   |                                                          OOO              |\n   |                                                             OOOO          |\n 65|                                                                 OOO       |\n   0                                                                        1.49 \n\n\nbranning_1.TextGrid\n[                words: 4/6 labeled intervals from 0 to 1.49                   ]\n[                phones: 15/17 labeled intervals from 0 to 1.49                ]\n[                nuclear: 1/3 labeled intervals from 0 to 1.49                 ]\n[                syllable: 2/4 labeled intervals from 0 to 1.49                ] \n\n\n\n\nNow that we have access to our PitchTier and TextGrid, we can convert them into data frame representations, again using sosprosody. We’ll limit our scope right now to just the phones tier.\n\n\nCode\n# TextGrid as a a dataframe\ntiers <- sosprosody::textgrid_to_dataframes(tg) # List of dfs for each tier\ntier_df <- tiers$phones # Extract a single tier\n\n# Small post processing steps\ntier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\ntier_df$interval_i <- seq_len(nrow(tier_df)) # Assign numeric indices\nhead(tier_df)\n\n\n        file interval_start interval_end label interval_i\n1 branning_1      0.0000000    0.1312844                1\n2 branning_1      0.1312844    0.2200000     m          2\n3 branning_1      0.2200000    0.2500000     ɑ          3\n4 branning_1      0.2500000    0.3800000     ʎ          4\n5 branning_1      0.3800000    0.4297910     i          5\n6 branning_1      0.4297910    0.4910510     z          6\n\n\nCode\n# Pitchtier as a dataframe, we don't need to calculate semitones and ERBs\npt_df <- sosprosody::pitchtier_to_dataframe(pt, \n                                            add_semitones = FALSE,\n                                            add_erbs = FALSE)\nhead(pt_df)\n\n\n        file timepoint       hz\n1 branning_1 0.1514512 89.57813\n2 branning_1 0.1614512 89.96063\n3 branning_1 0.1714512 89.98904\n4 branning_1 0.1814512 89.94582\n5 branning_1 0.1914512 89.89566\n6 branning_1 0.2014512 89.87433\n\n\nNext we’re going to use the new non-equi join functionality from dplyr. We want to match up the file in tier_df with the correct file in pt_df, then check for when the pulse timepoint (i.e., pt_df$timepoint) lies after interval_start and before interval_end. The choice of >= and < is largely arbitrary, you could do > and <= and get the same results unless you have pitch points that lie exactly on the boundary.\n\n\nCode\nlabeled_df <- \n  dplyr::left_join(pt_df, \n                   tier_df, \n                   join_by(file, \n                           timepoint >= interval_start, \n                           timepoint < interval_end))\n\nhead(labeled_df)\n\n\n        file timepoint       hz interval_start interval_end label interval_i\n1 branning_1 0.1514512 89.57813      0.1312844         0.22     m          2\n2 branning_1 0.1614512 89.96063      0.1312844         0.22     m          2\n3 branning_1 0.1714512 89.98904      0.1312844         0.22     m          2\n4 branning_1 0.1814512 89.94582      0.1312844         0.22     m          2\n5 branning_1 0.1914512 89.89566      0.1312844         0.22     m          2\n6 branning_1 0.2014512 89.87433      0.1312844         0.22     m          2\n\n\nTo check our work, let’s plot the pitch track to see what our result is like. Remember, we wanted to associate each pulse with the interval it appears in.\n\n\nCode\nlabeled_df |> \n  ggplot(aes(x = timepoint, y = hz, color = label, group = interval_i)) +\n  geom_line() +\n  geom_point() +\n  theme_bw(base_size = 14) +\n  # Add labels since there's a lot of colors\n  geom_label(data = summarize(group_by(labeled_df, label, interval_i),\n                              timepoint = median(timepoint),\n                              hz = median(hz) - 3),\n             aes(label = label)) +\n  theme(legend.position = 'none')\n\n\n\n\n\nLooks great! Now we can adapt this same basic workflow of loading our Praat objects, converting to dataframes, and doing a non-equi join and apply it to all the files in a directory. Note that if you extracted F0 measurements using a method other than exporting PitchTier files from Praat, then you can still do all the same steps above but just omit the part where you read in the PitchTier files. Ultimately, all we’re looking for is a dataframe that says what file(s) we have, what the pulse timepoints are, and what the frequency values at those timepoints are; how we get there doesn’t really matter."
  },
  {
    "objectID": "posts/pulselabeling/index.html#example-with-multiple-files",
    "href": "posts/pulselabeling/index.html#example-with-multiple-files",
    "title": "Pulse Labeling",
    "section": "Example with multiple files",
    "text": "Example with multiple files\nHere’s a pretty basic wrapper that encapsulates all of the previous steps into one function and operates over all the files in given directories containing TextGrids and PitchTiers.\n\n\n\n\n\n\nTip\n\n\n\nIf I were to do this for a larger set of files, I would probably split this up into two parts where I first load all the files then join them together. The reason being that if there’s an issue with joining the files in the below function, I would have to reload all the files again just to try the join again. Right now I’m only working with three files, so it doesn’t matter too much.\n\n\n\n\nCode\nlabel_pitch_pulses <- function(textgrid_dir = \"Files\", \n                               pitchtier_dir = \"Files\", \n                               tier = 'phones') {\n  # Note: This will fail if each textgrid does not have a corresponding\n  #       pitch tier file in the pitchtier directory\n  textgrids <- list.files(textgrid_dir, \n                          pattern = \".TextGrid$\",\n                          full.names = TRUE)\n  pitchtiers <- gsub(\".TextGrid$\", \".PitchTier\", textgrids, perl = TRUE)\n  \n  tg_dfs <- \n    map_dfr(textgrids,\n            \\(tg_path) {\n              tg <- rPraat::tg.read(tg_path, encoding = \"auto\")\n              tiers <- sosprosody::textgrid_to_dataframes(tg)\n              tier_df <- tiers[[tier]] \n              \n              # Small post processing steps\n              tier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\n              tier_df$interval_i <- seq_len(nrow(tier_df))\n              \n              tier_df\n            })\n  \n  pt_dfs <- \n    map_dfr(pitchtiers,\n            \\(pt_path) {\n              pt <- rPraat::pt.read(pt_path, encoding= \"auto\")\n              pt_df <- \n                sosprosody::pitchtier_to_dataframe(pt, \n                                                   add_semitones = FALSE,\n                                                   add_erbs = FALSE)\n              \n              pt_df\n            })\n  \n  # Execute the join\n  left_join(pt_dfs, \n            tg_dfs, \n            join_by(file, \n                    timepoint >= interval_start, \n                    timepoint < interval_end))\n  \n}\n\n\nAnd now the helper can be used to process all of our files; we’ll use it again later when we start working with syllables instead of phones.\n\n\nCode\nphone_labeled_df <- label_pitch_pulses()\n\n\nAs before, we can plot the pitch contours for each of our files to check our work.\n\n\nCode\nphone_labeled_df |> \n  ggplot(aes(x = timepoint, y = hz, group = interval_i, color = label)) +\n  geom_line() +\n  geom_point(size = .5) +\n  facet_wrap(~file) +\n  theme_bw(base_size = 14) +\n  geom_text(data = summarize(group_by(phone_labeled_df, file, label, interval_i),\n                             timepoint = median(timepoint),\n                             hz = median(hz) - 4),\n            aes(label = label)) +\n  theme(legend.position = 'none') +\n  coord_fixed(1/50)\n\n\n\n\n\nNext I’ll show an example of how this might be useful beyond just labeling and coloring our pitch contours by interval."
  },
  {
    "objectID": "posts/pulselabeling/index.html#piecewise-equal-pulses",
    "href": "posts/pulselabeling/index.html#piecewise-equal-pulses",
    "title": "Pulse Labeling",
    "section": "Piecewise equal pulses",
    "text": "Piecewise equal pulses\nThis is an example using the piecewise_interpolate_pulses function3 from sosprosody to get equally spaced pulses within each section.4 Here I’ll get 50 equally spaced pulses for each syllable in all of our words (which are all two syllables).\n\n\nCode\nsyllable_labeled_df <- \n  label_pitch_pulses(tier = 'syllable') |> \n  dplyr::filter(interval_i != 1) |> \n  rename(syllable = label)\n\nsyllable_labeled_df |> \n  # Get fifty equally spaced pulses for each interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = 50,\n                                           time_by = \"timepoint\",\n                                           .pitchval = \"hz\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint, y = hz, color= syllable, shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~file) +\n  coord_fixed(1/50)\n\n\n\n\n\nMoreover, piecewise_interpolate_pulses can be used to get a certain number of pulses per section. This allows you to upsample or downsample different parts of the utterance as needed (cf the above example upsampled across the board). Below, I’ll get 10 pulses for the first section and 40 pulses for the second.5\n\n\nCode\nsyllable_labeled_df |> \n  # Get different numbers of pulses by interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"timepoint\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top')\n\n\n\n\n\nIn the above plot, we can tell that at least one of the files have a pitch contour that starts a bit later than the others given the raw time on the x axis. This arises due to the slightly longer prenuclear material present in that utterance (the other two files were resynthesized from the same source file). We can time normalize these files such that the first syllable from each contour is directly comparable, i.e., they’ll all start at 0 and end at 1. And we can do that separately for the second syllable too. It’s more typical to time normalize by the duration of an entire word or utterance, but we’ll work with a more narrow case of time normalizing within each syllable. We address this problem with with much of the tools we’ve already used so far. Below I use the time_normalize function from sosprosody, which is a convenience wrapper that does the subtraction and division operations for time normalizing.6\n\n\nCode\n# Time normalize by syllable\nsyllable_labeled_df |> \n  group_by(file, interval_i) |> \n  sosprosody::time_normalize(.to = 'time_norm') |> \n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"time_norm\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = time_norm,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~syllable) +\n  coord_fixed(1/50)\n\n\n\n\n\n\nHandling overlapping pulses\nThere is one edge case that is worth mentioning: when a pitch pulse lines up exactly on the boundary between sections (i.e., intervals on a textgrid) This can especially happen when using something like the montreal forced aligner to set textgrid tier boundaries; the boundaries may be placed in steps of 10 milliseconds, which might be the same step with which pitch samples are returned. For example, say we have 20 pitch pulses from time 0 to 1, and this timespan is broken up into two sections from 0 to .5 and .5 to 1. If we want to label the pulses by which section they occur in, what do we do with a pulse that falls exactly at .5? Is it part of the first section? Or the second? Previously we addressed this in our non-equi join, associating such a point with the first section by joining on \\(min(sec_t) <= t < max(sec_t)\\). We could have associated it with the second section by joining on \\(min(sec_t) < t <= max(sec_t)\\). But if we joined on \\(min(sec_t) <= t <= max(sec_t)\\), then the time \\(t\\) at .5 would be duplicated, as there would be a point at .5 at the very end of the first section and another point at .5 at the very start of the second section.\nHere’s an example of what I mean with three sections. When all the sections are plotted together, the shared timepoints overlap.\n\n\nCode\noverlapping_df <- \n  data.frame(file = 'file1',\n             section = c(rep('a', times = 2),\n                         rep('b', times = 2),\n                         rep('c', times = 2)),\n             timestamp = c(seq(0,1,length.out = 2),\n                           seq(1, 1.4, length.out = 2),\n                           seq(1.4, 2, length.out = 2)),\n             hz = c(seq(90, 110, length.out = 2),\n                    seq(110, 70, length.out = 2),\n                    seq(70, 60, length.out = 2)))\noverlap_plot <- \n  overlapping_df |> \n  ggplot(aes(x = timestamp, y = hz, color = section, shape = section)) +\n  geom_line() +\n  geom_point(size = 3, aes(shape = section, fill = section),color ='black') +\n  scale_shape_manual(values = c(21, 22, 24)) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top')\n\noverlap_plot\noverlap_plot + \n  facet_grid(~section) + \n  theme(legend.position = 'none')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis situation causes some sticky situations when using the output of piecewise_interpolate_pulses; specifically, if you’re plotting or modeling using the resulting pulse indices. Below I interpolate 15 equally spaced points for each section, then plot by pulse index. We can see that for those points that overlapped, we get some regions that are flat, which should not be there.\n\n\nCode\noverlap_pulses <- \n  overlapping_df |> \n  piecewise_interpolate_pulses(section_by = 'section',\n                               pulses_per_section = 15,\n                               time_by = 'timestamp',\n                               .grouping = 'file')\n\noverlap_pulses |> \n  ggplot(aes(x = pulse_i, y = hz)) +\n  annotate(xmin = 14.5,\n           xmax = 16.5,\n           ymin = 108,\n           ymax = 112,\n           geom = 'rect',\n           fill = 'red',\n           alpha = .4) +\n  annotate(xmin = 29.5,\n           xmax = 31.5,\n           ymin = 68,\n           ymax = 72,\n           geom = 'rect',\n           fill = 'red',\n           alpha = .4) +\n  geom_line() +\n  geom_point(size = 3, aes(shape = section, fill = section)) +\n  scale_shape_manual(values = c(21, 22, 24)) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  coord_fixed(1/2)\n\n\n\n\n\nI’ve provided a post-processing function that can fix this (in case it’s too much trouble to try and go back and fix the original textgrids or join operations). For each instance where two adjacent pulses share the same timestamp, you can choose to keep either the left pulse (equivalent to if we had joined using \\(min(sec_t) < t <= max(sec_t)\\)) or the right pulse (=if we had joined using \\(min(sec_t) <= t < max(sec_t)\\)).\n\n\nCode\nadjusted_df_l <- \n  overlap_pulses |> \n  drop_overlapping_pulses(keep = 'left',\n                          time_by = 'timestamp',\n                          pulse_col = 'pulse_i',\n                          .grouping = 'file')\n\nadjusted_df_r <- \n  overlap_pulses |> \n  drop_overlapping_pulses(keep = 'right',\n                          time_by = 'timestamp',\n                          pulse_col = 'pulse_i',\n                          .grouping = 'file')\n\n\nkeep_left_plot <- \n  adjusted_df_l |> \n  ggplot(aes(x = pulse_i, y = hz)) +\n  geom_line() +\n  geom_point(size = 3, aes(shape = section, fill = section)) +\n  scale_shape_manual(values = c(21, 22, 24)) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  coord_fixed(1/2)\n\nkeep_right_plot <- \n  adjusted_df_r |> \n  ggplot(aes(x = pulse_i, y = hz)) +\n  geom_line() +\n  geom_point(size = 3, aes(shape = section, fill = section)) +\n  scale_shape_manual(values = c(21, 22, 24)) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'none') +\n  coord_fixed(1/2)\n\nkeep_left_plot\nkeep_right_plot\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote that we originally extracted 15 pulses for each section, but deleted one from each section that contained an overlap. As a result, the number of pulses for our three sections are not 15, 15, 15 but now 15, 14, 14 (if we kept the left pulse) or 14, 14, 15 (if we kept the right pulse). If we want to have 15 for everything in the output, then we’d need to specify pulses_per_section in piecewise_interpolate_pulses to be either c(15, 16, 16) or c(16, 16, 15) depending on which pulse we intend to keep with drop_overlapping_pulses.\nAnd that’s all! If you’d like to see a bigger example of how it might be useful to label regions of a pitch contour or extract equally spaced samples, you can take a look at the plots on this poster. I’ve used this approach to extract less pulses from the prenuclear region of the utterance and more pulses from the nuclear region, then average multiple pitch contours across the extracted pulses.\n\n\nCode\nsessionInfo()\n\n\nR version 4.2.2 (2022-10-31 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 22621)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] purrr_1.0.0           ggplot2_3.4.0         sosprosody_0.0.0.9000\n[4] rPraat_1.3.2-1        dplyr_1.1.0          \n\nloaded via a namespace (and not attached):\n [1] Rcpp_1.0.9        pillar_1.8.1      compiler_4.2.2    tools_4.2.2      \n [5] bit_4.0.5         digest_0.6.31     jsonlite_1.8.4    evaluate_0.20    \n [9] lifecycle_1.0.3   tibble_3.1.8      gtable_0.3.1      pkgconfig_2.0.3  \n[13] rlang_1.0.6       cli_3.5.0         rstudioapi_0.14   parallel_4.2.2   \n[17] yaml_2.3.7        xfun_0.37         fastmap_1.1.0     withr_2.5.0      \n[21] knitr_1.42        generics_0.1.3    vctrs_0.5.2       htmlwidgets_1.6.1\n[25] hms_1.1.2         bit64_4.0.5       grid_4.2.2        tidyselect_1.2.0 \n[29] glue_1.6.2        R6_2.5.1          fansi_1.0.3       vroom_1.6.1      \n[33] rmarkdown_2.20    farver_2.1.1      tzdb_0.3.0        readr_2.1.3      \n[37] magrittr_2.0.3    ellipsis_0.3.2    scales_1.2.1      htmltools_0.5.4  \n[41] colorspace_2.0-3  labeling_0.4.2    utf8_1.2.2        munsell_0.5.0    \n[45] crayon_1.5.2"
  }
]