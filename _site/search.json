[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "R pkg\n\n\n\n\nThis post gives an overview of an R package I’ve written. The contrastable package provides a tidy approach to contrast coding for regression analyses.\n\n\n\n\n\n\nJul 13, 2022\n\n\nThomas Sostarics\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/contrastable/index.html",
    "href": "posts/contrastable/index.html",
    "title": "Contrastable",
    "section": "",
    "text": "I’ve been working on a package called contrastable on and off for the past year or so. The package’s goal is to provide a tidy approach to setting factor contrasts for regression analysis. While this can be done with repeated contrasts<- calls, this workflow is tedious when working with multiple factors and especially error-prone when manually specifying contrast matrices to use. In this latter case, the user would need to be careful to specify the correct fractions in the correct order with the correct signs, which can be a lot to keep track of. These issues quickly become apparent when the number of factor levels is greater than 2. In this post I will:"
  },
  {
    "objectID": "posts/contrastable/index.html#contrasts-overview",
    "href": "posts/contrastable/index.html#contrasts-overview",
    "title": "Contrastable",
    "section": "Contrasts overview",
    "text": "Contrasts overview\nContrast coding refers to assigning numeric values to levels of a categorical variable for use in regression analyses. Depending on the numbers used, different comparisons can be made between the group means of a variable. These comparisons can correspond to particular null hypotheses that a researcher might have, and particular combinations of numbers can encode high-level questions like “Are there differences between levels when compared to a common reference level?” or “Does each level differ from the levels that came before it?” Critically, the contrasts used don’t impact the model fit but do impact the coefficient estimates that are used to make inferences about the data.\nIn most cases in Linguistics, people tend to want pairwise comparisons while retaining main effects in their model; e.g., the main effect of speech rate on intelligibility when L1 vs L2 speakers are considered as a categorical fixed effect. Many people realize (or are starting to at least) that the default1 “0/1 contrasts” (aka treatment or dummy coding) will only give them the simple effect of intelligibility; that is, the effect of intelligibility for just the L1 group. To rectify this, researchers will opt for “the +.5/-.5 contrasts” to obtain main effects.\n\n\n\n\n\n\nWarning: Naming inconsistency\n\n\n\nThe name for this contrast scheme is not consistent, especially in the 2-level case where the values are +.5/-.5. I’ve seen it called sum coding, simple coding, effects coding, scaled sum coding, helmert coding, difference coding, contrast coding, sum-to-zero coding, and +.5/-.5 coding. See Brehm and Alday (2022) for concerns about transparent descriptions of contrast coding schemes.\n\n\nWhile researchers may differ on what they call +.5/-.5, for 2 levels the result is nonetheless the same. But, a researcher using “helmert coding” and a researcher using “scaled sum coding” for a factor with 3 or more levels will be using very different contrast matrices, and thus address very different research questions about the data. Let’s use some functions from contrastable to look at how these contrast matrices differ.\n\nlibrary(contrastable)\n\n\n2 levels3 levels5 levels\n\n\n\nhelmert_code(2) |> MASS::fractions()\n\n     [,1]\n[1,]  1/2\n[2,] -1/2\n\nscaled_sum_code(2) |> MASS::fractions()\n\n  [,1]\n1  1/2\n2 -1/2\n\n\n\n\n\nhelmert_code(3) |> MASS::fractions()\n\n     [,1] [,2]\n[1,]  2/3    0\n[2,] -1/3  1/2\n[3,] -1/3 -1/2\n\nscaled_sum_code(3) |> MASS::fractions()\n\n  [,1] [,2]\n1  2/3 -1/3\n2 -1/3  2/3\n3 -1/3 -1/3\n\n\n\n\n\nhelmert_code(5) |> MASS::fractions()\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\nscaled_sum_code(5) |> MASS::fractions()\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\nNote that I use the term scaled sum coding for the “pairwise comparisons with main effects” contrast scheme. I opt for this term for three reasons.\n\nFirst, I see sum coding used more frequently in statistics and econometrics to refer to +1/-1; this is also what contr.sum in R returns.\nSecond, the salient part of going from sum coding to scaled sum coding, especially in the 2-level case, is that there’s some kind of division or scaling operation involved; I frequently see people use contr.sum(2)/2, although importantly contr.sum(3)/3 does not yield the expected result.\nThird, “simple” coding is counterintuitive to me since we’re trying to avoid “simple effects;” “effects coding” and “contrast coding” are largely meaningless as all coding schemes will encode some kind of effect, and setting any contrast matrix is an instance of contrast coding.\n\nSo, for the researcher trying to remember “I need to use those contrasts where they’re divided to get the main effects”, it (to me) seems easy to reach for a tool where scaled is in the name and is clearly distinguished from sum coding. 2"
  },
  {
    "objectID": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "href": "posts/contrastable/index.html#typical-approach-to-contrast-coding",
    "title": "Contrastable",
    "section": "Typical approach to contrast coding",
    "text": "Typical approach to contrast coding\nTypically when I see people in Linguistics set contrasts, they do something like the following, using the palmerpenguins dataset as an example.\n\n\nCode\nlibrary(tidyverse)\nlibrary(palmerpenguins)\npenguins_with_contrasts <- penguins\n\n# Default treatment/dummy coding for a 2 and 3 level factor\ncontrasts(penguins_with_contrasts$sex)\n\n\n       male\nfemale    0\nmale      1\n\n\nCode\ncontrasts(penguins_with_contrasts$species)\n\n\n          Chinstrap Gentoo\nAdelie            0      0\nChinstrap         1      0\nGentoo            0      1\n\n\nCode\n# Easy enough for 2 levels, -contr.sum(2)/2 is also used a lot\ncontrasts(penguins_with_contrasts$sex) <- c(-.5, .5) \n\n# Not so fun for three levels!\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 2/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\n\n\nThe chance of making a mistake increases when including more and more categorical variables. Catching these mistakes can be very difficult, in part because this workflow erases the labels in the regression output. This means you have to keep track of what 1 and 2 in the regression coefficients correspond to.\n\n\n\n\n\n\nNote: Column/Comparison/Coefficient names\n\n\n\nWhile the dimnames argument can be used to set the labels, anecdotally I rarely see people use this in their analyses when perusing code on the osf. Winter (2019, 127) notes that “Using the ‘1’ after the predictor name is a notational convention for representing the slopes of sum-coded predictors in R” but this is slightly incorrect; in the absence of dimnames being set, R will use the numeric indices of the contrast matrix’s columns (no matter what the scheme is).\n\n\nBelow, the two sets of coefficients represent pairwise comparisons to the Adelie baseline, but the intercepts differ due to how the contrasts are set, with the first using treatment coding and the second using scaled sum coding. I’ll start with a case that only considers the categorical variable, but will include an additional continuous independent variable later on.\n\n\nCode\n# Compare the default treatment coding with the penguins dataset\n# with the contrasts we specified in penguins_with_contrasts\ntreatment_coefs <- coef(lm(bill_length_mm ~ species,\n                           data = penguins))    \nscaledsum_coefs <- coef(lm(bill_length_mm ~ species, \n                           data = penguins_with_contrasts)) \n\n# I'm using list() to print and caption results side by side, purely aesthetic\nlist(\"(Default) Treatment Coding\" = treatment_coefs,\n     \"(Manual) Scaled Sum Coding\" = scaledsum_coefs)\n\n\n$`(Default) Treatment Coding`\n     (Intercept) speciesChinstrap    speciesGentoo \n       38.791391        10.042433         8.713487 \n\n$`(Manual) Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nHad we made a mistake in the manually-set contrast matrix, we would reach an incorrect conclusion about the difference between groups.\n\n\nCode\n# What if we accidentally typed 1/3 instead of 2/3?\ncontrasts(penguins_with_contrasts$species) <- matrix(c(-1/3, 1/3, -1/3,\n                                                       -1/3, -1/3, 2/3),\n                                                     nrow = 3)\nmistake_coefs <- coef(lm(bill_length_mm ~ species, \n                         data = penguins_with_contrasts))\n\nlist(\"(Current) Mistaken Scaled Sum Coding:\" = mistake_coefs,\n     \"(Previous) Correct Scaled Sum Coding:\" = scaledsum_coefs)\n\n\n$`(Current) Mistaken Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`(Previous) Correct Scaled Sum Coding:`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n\nHere we can see that the intercept and the value for species1 has changed. To what though?? What does the new coefficient estimate represent?\n\nDiagnosing our mistake\nTo check what these numbers correspond to, we have to check the hypothesis matrix that corresponds to our contrast matrix. The process of obtaining the hypothesis matrix has been referred to as finding the generalized inverse of the contrast matrix (see Schad et al. 2020 for details).\n\n\nCode\nmatrix(c(1, 1, 1,         # Add a column of 1s for the intercept\n         -1/3, 1/3, -1/3,\n         -1/3, -1/3, 2/3),\n       nrow = 3,\n       dimnames = list(NULL, c('Intercept', 'species1', 'species2'))) |> \n  t() |> \n  solve() |> \n  MASS::fractions() # This function just shows numbers as fractions\n\n\n     Intercept species1 species2\n[1,]  1/6      -3/2       -1    \n[2,]  1/2       3/2        0    \n[3,]  1/3         0        1    \n\n\nHere the intercept is represented by the weighted sum of each group mean, where the weights are shown in the intercept column. In most cases, the intercept should reflect the grand mean, or the mean of the group means, and so would usually have equal weights (i.e., 1/3 here) for the levels. In this case, we see the fractional weights are not the same. We can verify this by calculating the weighted mean ourselves:\n\n\nCode\ngroup_means <- \n  penguins |>\n  dplyr::group_by(species) |> \n  dplyr::summarize(mean_length = mean(bill_length_mm, na.rm = TRUE)) |> \n  purrr::pluck('mean_length') |> \n  `names<-`(c('Adelie', 'Chinstrap', 'Gentoo'))\n\ngroup_means\n\n\n   Adelie Chinstrap    Gentoo \n 38.79139  48.83382  47.50488 \n\n\nCode\nlist(\"Grand Mean\" = mean(group_means),\n     \"Weighted mean\" = weighted.mean(group_means, c(1/6, 1/2, 1/3)))\n\n\n$`Grand Mean`\n[1] 45.04336\n\n$`Weighted mean`\n[1] 46.7171\n\n\nSimilarly, the coefficient for species1 shows the difference between the group means of levels 1 and 2 (i.e., mean of Chinstrap - mean of Adelie) but times a factor of 3/2. Crucially, if our goal is to evaluate the difference between the means of these two levels, then our mistake in coding the hypothesis matrix will give us a larger estimate (~15 vs 10). Consider a similar setup where the larger estimate was 5 instead of 0; if we were relying on null hypothesis testing it’s possible we’d get a significant effect when really we shouldn’t have.\n\n\nCode\nlist(\"Mistaken Scaled Sum Coding\" = mistake_coefs,\n     \"Correct Scaled Sum Coding\" = scaledsum_coefs,\n     \"Computed Chinstrap-Adelie Difference with 3/2 scaling\" = \n       (3/2 * group_means[['Chinstrap']]) - (3/2 * group_means[['Adelie']]),\n     \"Actual Chinstrap-Adelie Difference\" = \n       group_means[['Chinstrap']] - group_means[['Adelie']])\n\n\n$`Mistaken Scaled Sum Coding`\n(Intercept)    species1    species2 \n  46.717103   15.063649    8.713487 \n\n$`Correct Scaled Sum Coding`\n(Intercept)    species1    species2 \n  45.043364   10.042433    8.713487 \n\n$`Computed Chinstrap-Adelie Difference with 3/2 scaling`\n[1] 15.06365\n\n$`Actual Chinstrap-Adelie Difference`\n[1] 10.04243\n\n\nPoint being: we made an honest mistake of typing 1/3 instead of 2/3 but this had ramifications for the coefficients in our model output that we use to make inferences. In practice, because we did the multiple contrasts<- calls, we would likely assume that what we did was correct in the absence of any errors."
  },
  {
    "objectID": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "href": "posts/contrastable/index.html#tidy-approach-to-contrasts",
    "title": "Contrastable",
    "section": "Tidy approach to contrasts",
    "text": "Tidy approach to contrasts\nHere I’ll show a different approach using the contrastable package. This package takes a tidy approach to take care of the overhead of labels and reference levels involved when using common contrast coding schemes. Specifically, this package provides a series of functions that use a special formula implementation that assigns specific meanings to each operator. The left hand side of the formula is the factor column whose contrasts you want to change. The right hand side consists of (at minimum) a function to generate contrast matrices such as contr.treatment or treatment_code. Additional operators provide extra optional functionality:\n\n+ x: Set reference level to level x\n* x: Set intercept to be the mean of x\n- 3:4: For polynomial contrasts only, drop trends 3 and 4\n| c(\"A-B\", \"A-C\"): Set the comparison labels to A-B and A-C (must be the last operator if used)\n\nRecall that in many cases researchers want pairwise comparisons while retaining main effects, and so the choice of reference level for the comparisons is very important. By default, R uses the first level alphabetically as the reference level, but sometimes we want to change this manually ourselves. Here’s an example where we set the sex and species factors to the two contrast schemes we manually set before. The set_contrasts function will show a message if it detects additional factor variables in the dataframe that the user did not provide contrasts for.\n\n\nCode\n# library(contrastable) was loaded earlier\npenguins_df <- \n  penguins |> \n  set_contrasts(sex ~ scaled_sum_code + \"male\", # Set reference level with +\n                species ~ scaled_sum_code + 'Adelie') \n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\nCode\ncontrasts(penguins_df$species) |> MASS::fractions()\n\n\n          Chinstrap Gentoo\nAdelie    -1/3      -1/3  \nChinstrap  2/3      -1/3  \nGentoo    -1/3       2/3  \n\n\nCode\ncontrasts(penguins_df$sex) |> MASS::fractions()\n\n\n       female\nfemale  1/2  \nmale   -1/2  \n\n\npenguins_df now has its contrasts set, and we can run our model as usual. Note that we didn’t have to type out any matrices ourselves, but we got the correct contrasts that we needed.\n\n\nCode\ncoef(lm(bill_length_mm ~ species + bill_depth_mm, data = penguins_df))\n\n\n     (Intercept) speciesChinstrap    speciesGentoo    bill_depth_mm \n       20.997115         9.938955        13.403279         1.394011 \n\n\nIf we wanted to change the labels to better reflect the comparisons being made, we could do that in the formula too with the | operator.\n\n\nCode\npenguins_df <- \n  penguins_df |> \n  set_contrasts(species ~ scaled_sum_code + 'Adelie' | \n                  c('Chinstrap-Ad', 'Gentoo-Ad'))\n\ncoef(lm(bill_length_mm ~ species, data = penguins_df))\n\n\n        (Intercept) speciesChinstrap-Ad    speciesGentoo-Ad \n          45.043364           10.042433            8.713487 \n\n\n\nAdditional functions\nTypically when I use this package in my analyses the set_contrasts function is all I really need, but there are other functions that follow the same syntax that provide other information. To avoid retyping things, I’ll usually keep the contrasts in a list assigned to a separate variable and pass that to functions.\nThe glimpse_contrasts function can show information about the factors in a dataset along with the contrast schemes that have been assigned to each factor.\n\n\nCode\nmy_contrasts <- \n  list(\n    sex ~ scaled_sum_code + 'female',\n    species ~ helmert_code\n  )\n\nglimpse_contrasts(penguins_df, my_contrasts) |> gt::gt()\n\n\n\n\n\n\n  \n  \n    \n      factor\n      n_levels\n      level_names\n      scheme\n      reference\n      intercept\n      orthogonal\n      centered\n      dropped_trends\n      explicitly_set\n    \n  \n  \n    sex\n2\nfemale, male\nscaled_sum_code\nfemale\ngrand mean\nNA\nTRUE\nNA\nTRUE\n    species\n3\nAdelie, Chinstrap, Gentoo\nhelmert_code\nGentoo\ngrand mean\nTRUE\nTRUE\nNA\nTRUE\n    island\n3\nBiscoe, Dream, Torgersen\ncontr.treatment\nBiscoe\nmean(Biscoe)\nFALSE\nFALSE\nNA\nFALSE\n  \n  \n  \n\n\n\n\nThe enlist_contrasts function does the same thing as set_contrasts, but returns a list of contrast matrices that can be used in the contrasts argument of some model-fitting functions.3 It also provides an easy way to show the contrast matrices in an appendix or supplementary material.\n\n\nCode\nenlist_contrasts(penguins_df, my_contrasts) |> purrr::map(MASS::fractions)\n\n\nExpect contr.treatment or contr.poly for unset factors: island\n\n\n$sex\n       male\nfemale -1/2\nmale    1/2\n\n$species\n          >Adelie >Chinstrap\nAdelie     2/3       0      \nChinstrap -1/3     1/2      \nGentoo    -1/3    -1/2      \n\n\n\n\nAvailable contrast schemes\nHere are the different contrast functions this package currently provides.\n\nTreatmentSumScaled SumHelmertReverse HelmertForward DifferenceBackward DifferenceOrthogonal PolynomialsRaw Polynomials\n\n\n\n\nCode\n# = contr.treatment\ntreatment_code(5) |> MASS::fractions()\n\n\n  2 3 4 5\n1 0 0 0 0\n2 1 0 0 0\n3 0 1 0 0\n4 0 0 1 0\n5 0 0 0 1\n\n\n\n\n\n\nCode\n# = contr.sum\nsum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  1    0    0    0  \n2  0    1    0    0  \n3  0    0    1    0  \n4  0    0    0    1  \n5 -1   -1   -1   -1  \n\n\n\n\n\n\nCode\n# = contr.sum\nscaled_sum_code(5) |> MASS::fractions()\n\n\n  [,1] [,2] [,3] [,4]\n1  4/5 -1/5 -1/5 -1/5\n2 -1/5  4/5 -1/5 -1/5\n3 -1/5 -1/5  4/5 -1/5\n4 -1/5 -1/5 -1/5  4/5\n5 -1/5 -1/5 -1/5 -1/5\n\n\n\n\n\n\nCode\n# NOT = contr.helmert, which is unscaled\nhelmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5    0    0    0\n[2,] -1/5  3/4    0    0\n[3,] -1/5 -1/4  2/3    0\n[4,] -1/5 -1/4 -1/3  1/2\n[5,] -1/5 -1/4 -1/3 -1/2\n\n\n\n\n\n\nCode\nreverse_helmert_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -1/2 -1/3 -1/4 -1/5\n[2,]  1/2 -1/3 -1/4 -1/5\n[3,]    0  2/3 -1/4 -1/5\n[4,]    0    0  3/4 -1/5\n[5,]    0    0    0  4/5\n\n\n\n\n\n\nCode\nforward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,]  4/5  3/5  2/5  1/5\n[2,] -1/5  3/5  2/5  1/5\n[3,] -1/5 -2/5  2/5  1/5\n[4,] -1/5 -2/5 -3/5  1/5\n[5,] -1/5 -2/5 -3/5 -4/5\n\n\n\n\n\n\nCode\nbackward_difference_code(5) |> MASS::fractions()\n\n\n     [,1] [,2] [,3] [,4]\n[1,] -4/5 -3/5 -2/5 -1/5\n[2,]  1/5 -3/5 -2/5 -1/5\n[3,]  1/5  2/5 -2/5 -1/5\n[4,]  1/5  2/5  3/5 -1/5\n[5,]  1/5  2/5  3/5  4/5\n\n\n\n\n\n\nCode\n# = contr.poly, poly(1:n, degree = n-1, raw = FALSE)\north_polynomial_code(5) |> MASS::fractions()\n\n\n     .L                .Q                .C                ^4               \n[1,]          -265/419          929/1738  -2026009/6406803        4018/33617\n[2,]  -2026009/6406803         -809/3027           191/302    -246481/515552\n[3,]                 0       -6263/11717                 0         1042/1453\n[4,] 12484830/39480499         -809/3027          -265/419    -246481/515552\n[5,]           191/302          929/1738 10458821/33073696        4018/33617\n\n\n\n\n\n\nCode\n# = poly(1:n, degree = n-1, raw = TRUE)\nraw_polynomial_code(5) |> MASS::fractions()\n\n\n     1   2   3   4  \n[1,]   1   1   1   1\n[2,]   2   4   8  16\n[3,]   3   9  27  81\n[4,]   4  16  64 256\n[5,]   5  25 125 625"
  },
  {
    "objectID": "posts/contrastable/index.html#other-packages-and-resources",
    "href": "posts/contrastable/index.html#other-packages-and-resources",
    "title": "Contrastable",
    "section": "Other packages and resources",
    "text": "Other packages and resources\nThis package is not the first package made for contrast coding, though to my knowledge it is the first to take a “tidy” approach to it.\nThe hypr package (Rabe et al. 2020) takes a different approach, where the focus is on considering the hypothesis matrix and declaring specifically which comparisons you want to make, then the package can provide a corresponding matrix. I like hypr a lot actually, but I find it a bit tedious when I know what the contrast matrix should look like but I have to type out the comparisons; still better than matrix calls though.\nThe emmeans package (Lenth 2022) is extremely useful for making pairwise comparisons, but is capable of a lot more as well. You can see its vignette on contrasts here.\nThe multcomp package (Hothorn, Bretz, and Westfall 2008) is useful for simultaneous inference, which seeks to extend workflows for multiple comparisons.\nI haven’t used the contrasts package (O’Callaghan 2021) very much, but judging from its vignette here it seems like it extends the rms package’s contrast function (Harrell Jr 2022). It seems useful for calculating different comparisons after a model is run, but its usage isn’t very transparent to me on first glance.\nWhile not a package, this page from UCLA pops up a lot when people discuss contrast coding. It’s very useful, and I used it as a starting point for implementing different contrast functions. However, I will note that I don’t follow its naming conventions."
  }
]