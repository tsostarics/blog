{
  "hash": "3ebaa5c20dcb1a0d36a865444ab7615f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Making inline statistics commands for LaTeX using R\"\nformat: html\nself-contained: true\nauthor: \n - name: Thomas Sostarics\n - url: https://tsostarics.com/\n - affiliation: Northwestern University Department of Linguistics\n - orcid: 0000-0002-1178-7967\ndate: '2024-04-28'\ncitation:\n  url: https://tsostaricsblog.netlify.app/posts/latexswitch\neditor: source\ndescription: \"This post shows how to make latex commands to insert model statistics.\"\ntoc: true\nimage: false\ncategories: ['R', 'LaTeX']\ncode-tools: true\ncode-fold: show\nexecute: \n  warning: false\nknitr: \n  opts_chunk: \n    message: false\n---\n\n\nIn this post I describe a workflow approach for reproducible reporting of inline\nstatistics for researchers who do their analysis in R but the final writeup in\nLaTeX/Overleaf without writing in RMarkdown as an intermediate step. If you are\na diehard RMarkdown/Quarto-only fan, then this is not for you.\nIf you just want to see how the final function works on Overleaf, \nskip to the last section.\n\nIf you want to use the final code that we build up here, you can download the\nsource file from my github [here](https://github.com/tsostarics/sosdiss2/blob/main/R/make_latex_switch.R).\nNote that this version is slightly different than what's used here, but is\ngenerally equivalent in functionality.\nAlso, this file is part of a larger package of convenience functions for my\ndissertation, so I'd recommend just downloading the one R file instead of\ninstalling the package.\n\n\n## Motivation \n\nI've used R, RMarkdown, and Quarto documents throughout grad school and\ngenerally like using them for organizing my analyses and notes. But, I've been\nwriting papers (and homework writeups, handouts, etc.) using LaTeX for well over\n12 years now--- since before ShareLatex merged with Overleaf. I can appreciate\nRMarkdown and Quarto's capabilities for writing articles but honestly the few\ntimes I've tried to stick solely with Quarto I couldn't quite reach the level of\nflexibility in PDF output that I get out the box with LaTeX.\n\nOne approach I've taken in previous work was to write *just* my results/analysis\nsections using RMarkdown, then render that to a LaTeX fragment (no preamble,\nbegin document, etc.) that I can `\\input` into my main LaTeX document. This was\nnice because I could do tricks like using tibbles or lists to keep track of\nstatistical results (see [TJ Mahr's post here with an\nexample](https://tjmahr.com/lists-knitr-secret-weapon/)) and\nwrite functions to format and insert inline statistics like\n`$(\\hat\\beta=0.6, 95\\% CI: [0.21,0.98])$` for me without ever needing to worry\nabout handling the numbers by hand. Add a bash script to push the rendered .tex\nfiles to a repository, sync that with overleaf, and everything would be as it\nshould be. But, this means that if I wanted to edit the results section after\nreading it in Overleaf, I would have to remember to sync my overleaf changes,\nchange the RMarkdown file, rerender, then push the new .tex file again. It\nbecame a bit cumbersome whenever I only needed to do small prose changes that\nhad nothing to do with the numbers.\n\nSo here's a different approach focused on better handling the division of labor\nbetween prose and inline statistics, but can generalize to things like tables.\nThe goal is to replicate inline R functionality in RMarkdown, where for example\nwe might have our statistics in a list called `model_stats`, which we can index\nlike ` r model_stats$my_effect`, assuming this would result in a number or a\nformatted inline statistics string. So, we're going to use R to create a LaTeX\ncommand like `\\modelStats{my_effect}`, which we can then source into our LaTeX\nproject The benefit here is that the only thing R exports is the numbers for the\nanalysis, not the prose, so we only need to worry about occasionally updating\nour commands on the R side.\n\nI'm going to show a simple example that I've done recently that's been working\nquite well for writing my thesis. It isn't intended to necessarily work out of\nthe box for every type of model, but I'll point out a couple of workarounds I\nused and some potential extensions. This command is basically just a switch\nstatement.[^1] I'm basing the LaTeX implementation on the discussion from [this\nstackexchange\npost](https://tex.stackexchange.com/questions/508268/expandable-case-insensitive-switch-case-for-string-comparison),\nso give it a look if you're curious.\n\n[^1]: For those unfamiliar, a switch statement (oversimplified) is like a series\n    of multiple conditionals, so instead of writing out if x=A, B else if x=C, D\n    else if \\[...\\] else Z, you can write something like switch(x) A->B, C->D,\n    \\[...\\], Z.\n\n## The LaTeX part: Writing the command\n\nThe command we're going to write looks something like the below. I'm not an\nexpert on `expl3` syntax, but here's the gist of what's going on:\n\n-   Define a boolean value so we know when we've matched a coefficient\n-   Define a new command `statvalue` that takes a single argument. We need to\n    use `m` otherwise the command won't work when used inside of other commands\n    like `footnote{}`\n-   Take whatever we give to `statvalue`, `#1`, and standardize the\n    capitalization using foldcase (basically, make it all lowercase but\n    technically it's not merely lowercasing)\n-   Look through our switch cases, formatted as `{ matchtext } { result }`. If\n    `#1` matches with `matchtext`, then we flag that we found a match by setting\n    our boolean `found` to true, then return the rest of the result (formatted\n    text).\n-   If we don't find a match, then `found` is still false, so we'll return ERROR\n    in big red letters so we can see it in the rendered text.\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n\\ExplSyntaxOn\n\\newboolean{found}\n\\setboolean{found}{false}\n\\NewDocumentCommand \\statvalue{ m }\n{\n\\str_case_e:nn { \\str_foldcase:e { #1 } }\n{\n{ groupTreatment } { \\setboolean{found}{true} $(\\hat\\beta = 0.79, CI=[0.58,0.99]), p<.001$ }\n{ age } { \\setboolean{found}{true} $(\\hat\\beta = 0.09, CI=[-0.21,0.15]), p<.001$ }\n}\n\\ifthenelse{\\boolean{found}}{}{{\\color{red} \\large ERROR}}\n\\setboolean{found}{false}\n}\n\\cs_generate_variant:Nn \\str_foldcase:n { e }\n\\ExplSyntaxOff\n```\n:::\n\n\nSo then we can write text like:\n\n```         \nWe find a credible effect of group \\statvalue{groupTreatment} such \nthat the treatment group has higher levels of (whatever).\nThere was no significant effect of age \\statvalue{age}.\n```\n\nWhich then is replaced under the hood with:\n\n```         \nWe find a significant effect of group $(\\hat\\beta = 0.79, CI=[0.58,0.99], p<.001)$ such \nthat the treatment group has higher levels of (whatever).\nThere was no significant effect of age $(\\hat\\beta = 0.09, CI=[-0.21,0.15], p=.63)$.\n```\n\nSo, our work on the R front has two parts. First, we need the boilerplate for\nthe command. Second, we need to format our model results as a string and then\ninject it into the boilerplate.\n\n## The R part 1: Getting the modeling results ready\n\nFirst I'll fit a very simple mixed model, I'll ignore the singularity warning\nsince this is just an example so we have something to work with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins) # For dataset\nlibrary(lme4)           # For mixed models\nlibrary(lmerTest)       # For p value output\n\npenguin_model <- \n  lmer(bill_length_mm ~ bill_depth_mm * species  + (1|island), \n       data = palmerpenguins::penguins)\n\nsummary(penguin_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: bill_length_mm ~ bill_depth_mm * species + (1 | island)\n   Data: palmerpenguins::penguins\n\nREML criterion at convergence: 1582.9\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-3.1860 -0.6306  0.0235  0.6493  4.2374 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n island   (Intercept) 0.000    0.000   \n Residual             5.976    2.445   \nNumber of obs: 342, groups:  island, 3\n\nFixed effects:\n                               Estimate Std. Error       df t value Pr(>|t|)\n(Intercept)                     23.0681     3.0165 336.0000   7.647 2.18e-13\nbill_depth_mm                    0.8570     0.1641 336.0000   5.224 3.08e-07\nspeciesChinstrap                -9.6402     5.7154 336.0000  -1.687 0.092590\nspeciesGentoo                   -5.8386     4.5353 336.0000  -1.287 0.198850\nbill_depth_mm:speciesChinstrap   1.0651     0.3100 336.0000   3.435 0.000666\nbill_depth_mm:speciesGentoo      1.1637     0.2789 336.0000   4.172 3.84e-05\n                                  \n(Intercept)                    ***\nbill_depth_mm                  ***\nspeciesChinstrap               .  \nspeciesGentoo                     \nbill_depth_mm:speciesChinstrap ***\nbill_depth_mm:speciesGentoo    ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) bll_d_ spcsCh spcsGn bl__:C\nbll_dpth_mm -0.998                            \nspcsChnstrp -0.528  0.527                     \nspeciesGent -0.665  0.664  0.351              \nbll_dpth_:C  0.528 -0.529 -0.998 -0.351       \nbll_dpth_:G  0.587 -0.588 -0.310 -0.993  0.311\noptimizer (nloptwrap) convergence code: 0 (OK)\nboundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n:::\n\n\nHurray, lots of p<.05, time to publish[^thisisajoke] In our results section\nwe'll report on the effect estimate $\\hat\\beta$, the 95% confidence interval,\nand the $p$ value, but we need to format all this information in a consistent\nway. We can always add more information as needed (e.g., if a reviewer says they\nwant the $t$ value reported inline as well). We'll use `broom.mixed::tidy` to\nget just our fixed effect estimates, and then I'll do some quick rounding and\npost processing of the p values.\n\n[^thisisajoke]: This is a joke if it isn't obvious.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom.mixed)\nlibrary(dplyr)\n\nmodel_results <- \n  penguin_model |> \n  tidy(effects='fixed', conf.int = TRUE) |> \n  dplyr::mutate(p.value = scales::pvalue(p.value,accuracy = .01,add_p = TRUE),\n                across(where(is.numeric), ~round(.,2)),)\n\nmodel_results\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n  effect term      estimate std.error statistic    df p.value conf.low conf.high\n  <chr>  <chr>        <dbl>     <dbl>     <dbl> <dbl> <chr>      <dbl>     <dbl>\n1 fixed  (Interce…    23.1       3.02      7.65   336 p<0.01     17.1      29   \n2 fixed  bill_dep…     0.86      0.16      5.22   336 p<0.01      0.53      1.18\n3 fixed  speciesC…    -9.64      5.72     -1.69   336 p=0.09    -20.9       1.6 \n4 fixed  speciesG…    -5.84      4.54     -1.29   336 p=0.20    -14.8       3.08\n5 fixed  bill_dep…     1.07      0.31      3.44   336 p<0.01      0.46      1.67\n6 fixed  bill_dep…     1.16      0.28      4.17   336 p<0.01      0.62      1.71\n```\n\n\n:::\n:::\n\n\nNow, we need to modify the terms a bit to make them more amenable to the pattern\nmatching for the LaTeX command. Specifically, we'll need to lowercase everything\nand change the `:` character to something else. Since `i` is used for\ninteractions, I'll change it to `i`. Looking ahead, we'll also drop the\nparentheses for the intercept since it looks weird to write\n`\\stavalue{(intercept)}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_results <- mutate(model_results,\n                        term = tolower(term),\n                        term = gsub(\":\", \"i\", term),\n                        term = gsub(\"[)(]\", \"\", term))\n\nmodel_results$term\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"intercept\"                      \"bill_depth_mm\"                 \n[3] \"specieschinstrap\"               \"speciesgentoo\"                 \n[5] \"bill_depth_mmispecieschinstrap\" \"bill_depth_mmispeciesgentoo\"   \n```\n\n\n:::\n:::\n\n\nWe can wrap all these steps into a function to use with other models later on:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocess_coefs <- function(mdl) {\n  mdl |> \n    broom.mixed::tidy(effects='fixed', conf.int = TRUE) |> \n    dplyr::mutate(p.value = scales::pvalue(p.value,accuracy = .01,add_p = TRUE),\n                  across(where(is.numeric), ~round(.,2)),\n                  term = tolower(term),\n                  term = gsub(\":\", \"i\", term),\n                  term = gsub(\"[)(]\", \"\", term))\n}\n```\n:::\n\n\n## The R part 2: Writing the boilerplate command\n\nWhat we want is a function that takes our model results dataframe and spits out\na formatted LaTeX command. If we think we might have more than 1 model to\nreport, we're going to need parameters to name the command and a boolean to omit\nthe `found` boolean.[^2] We'll also add a parameter for the formatted inline\nstats strings, in case we need to modify what/how we report at a later point.\nThis will get injected into the case boilerplate. Here is the pseudocode for the\nfunction in case you want to think or work through the steps yourself.\n\n[^2]: The boolean value only needs to be defined once in the document, so we\n    want to include it for our first command but not redefine it multiple times,\n    as this will throw an error in LaTeX.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_latex_switch <- \n  function(model_coef_df,\n           fstring = r\"($(\\hat\\beta = {estimate}, CI=[{conf.low},{conf.high}])$)\",\n           command_name = \"statvalue\",\n           add_found_boolean = TRUE) {\n    \n    # Set up the start of the command with the expl3 lines\n    \n    # Check whether we need to add the found boolean\n    \n    # Set up the first couple of lines\n    \n    \n    # Take the formatted string from the user and embed it within the syntax\n    # needed for the conditional statements\n    \n    # Take the full formatted string and inject the model values\n    \n    # Add together all the lines, along with the ending parts to close off the\n    # command definition\n    \n    # Print the new expression with the newlines in a copy-pasteable format\n    \n    # Return the lines as a character vector in case the user wants to hold on\n    # to them (which is reasonable)\n  }\n```\n:::\n\n\nAnd here is the function filled out.[^growingnote] Note that there are of\ncourse other ways to implement this. For example, we might create a named list\nof formatted strings outside of this function then iterate over the names and\nvalues of that list to inject them into the boilerplate.\n\n[^growingnote]: Yes yes I know we're growing a vector, let's set that issue\naside for the time being. One could imagine a different implementation where the\nentire boilerplate is created beforehand and only joined with the model lines at\nthe end. Performance is not a huge issue for this kind of thing unless you're\ntrying to make thousands of commands in bulk, in which case you probably have\nother more serious problems to deal with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_latex_switch <- \n  function(model_coef_df,\n           command_name = \"statvalue\",\n           fstring = r\"($(\\hat\\beta = {estimate}, CI=[{conf.low},{conf.high}], {p.value})$)\",\n           add_found_boolean = TRUE) {\n    \n    # Set up the start of the command with the expl3 lines\n    starting_lines <- c(r\"(\\ExplSyntaxOn)\")\n    \n    # Base case is handled by a boolean called \"found\", if we have already defined\n    # this elsewhere then we can omit it as needed\n    if (add_found_boolean)\n      starting_lines <- c(starting_lines, r\"(\\newboolean{found})\")\n    \n    starting_lines <-\n      c(\n        starting_lines,\n        r\"(\\setboolean{found}{false})\",\n        paste0(r\"(\\NewDocumentCommand \\)\", command_name, r\"({ m })\"), \n        r\"(  {)\",\n        r\"(    \\str_case_e:nn { \\str_foldcase:e { #1 } })\",\n        r\"(      {)\")\n    \n    \n    # Take the formatted string from the user and embed it within the syntax\n    # needed for the conditional statements\n    fstring <- \n      paste0(\n        \"        {{ {term} }} {{ \\\\setboolean{{found}}{{true}} \", fstring, \" }}\"\n      )\n    \n    # Take the full formatted string and inject the model values\n    mdl_lines <- glue::glue(fstring, .envir = model_coef_df)\n    \n    # Add together all the lines, along with the ending parts to close off the\n    # command definition\n    all_lines <-\n      c(starting_lines,\n        mdl_lines,\n        r\"(      })\",\n        r\"(    \\ifthenelse{\\boolean{found}}{}{{\\color{red} \\large ERROR}})\",\n        r\"(    \\setboolean{found}{false})\",\n        r\"(  })\",\n        r\"(\\cs_generate_variant:Nn \\str_foldcase:n { e })\",\n        r\"(\\ExplSyntaxOff)\") |>\n      paste0(\"\\n\") # add newlines for formatting\n    \n    # Print the new expression with the newlines in a copy-pasteable format\n    cat(all_lines)\n    \n    # Return the lines as a character vector in case the user wants to hold on\n    # to them (which is reasonable)\n    invisible(all_lines)\n  }\n```\n:::\n\n\n## The integration part\n\nSo now we have our function and model results, let's make some commands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguin_model |> \nprocess_coefs() |> \n  make_latex_switch(\"statValue\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\\ExplSyntaxOn\n \\newboolean{found}\n \\setboolean{found}{false}\n \\NewDocumentCommand \\statValue{ m }\n   {\n     \\str_case_e:nn { \\str_foldcase:e { #1 } }\n       {\n         { intercept } { \\setboolean{found}{true} $(\\hat\\beta = 23.07, CI=[17.13,29], p<0.01)$ }\n         { bill_depth_mm } { \\setboolean{found}{true} $(\\hat\\beta = 0.86, CI=[0.53,1.18], p<0.01)$ }\n         { specieschinstrap } { \\setboolean{found}{true} $(\\hat\\beta = -9.64, CI=[-20.88,1.6], p=0.09)$ }\n         { speciesgentoo } { \\setboolean{found}{true} $(\\hat\\beta = -5.84, CI=[-14.76,3.08], p=0.20)$ }\n         { bill_depth_mmispecieschinstrap } { \\setboolean{found}{true} $(\\hat\\beta = 1.07, CI=[0.46,1.67], p<0.01)$ }\n         { bill_depth_mmispeciesgentoo } { \\setboolean{found}{true} $(\\hat\\beta = 1.16, CI=[0.62,1.71], p<0.01)$ }\n       }\n     \\ifthenelse{\\boolean{found}}{}{{\\color{red} \\large ERROR}}\n     \\setboolean{found}{false}\n   }\n \\cs_generate_variant:Nn \\str_foldcase:n { e }\n \\ExplSyntaxOff\n```\n\n\n:::\n:::\n\n\nWe can take the output of this and just copy paste it into our preamble on\noverleaf like in the below picture. Note that we need to include the `xparse`\nand `ifthen` packages (if one of your packages doesn't already include them). We\ncan ignore the error that overleaf flags on line 23, it's just because of the\nexpl3 syntax.\n\n![](img2.png)\n\nThen we can type our LaTeX writeup and render it like so:\n\n![](img1.png)\n\nIf we have multiple models, then we might want to write a new tex file that we\ncan source into the project instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmdl2 <- lmer(flipper_length_mm ~ body_mass_g + (1|species), \n             data = palmerpenguins::penguins)\nmdl3 <- lmer(bill_depth_mm ~ body_mass_g*bill_length_mm + (1|sex) + (1|species), \n             data = palmerpenguins::penguins)\nswitch1 <- make_latex_switch(process_coefs(penguin_model), \"statValue\")\nswitch2 <- make_latex_switch(process_coefs(mdl2), \"flipperModelValue\",add_found_boolean = FALSE)\nswitch3 <- make_latex_switch(process_coefs(mdl3), \"depthModelValue\",add_found_boolean = FALSE)\n\nc(switch1, switch2, switch3) |> \n  writeLines(\"inlinestats.tex\", sep = \"\")\n```\n:::\n\n\nThen we can add that tex file to our overleaf project and clean up our preamble\naccordingly:\n\n![](img3.png)\n\nFull document code below:\n\n\n::: {.cell}\n\n```{.latex .cell-code}\n\\documentclass[]{article}\n\\usepackage{xcolor} % for color\n\\usepackage{xparse} % for expl3 syntax\n\\usepackage{ifthen} % for boolean checks\n\n\\input{inlinestats}\n\n\\begin{document}\nWe find a significant conditional effect of bill depth for Adelie penguins \\statValue{bill_depth_mm} such that bill length is positively associated with bill depth.\nThere is not a significant difference between the average bill lengths for chinstrap penguins \\statValue{specieschinstrap} nor gentoo penguins \\statValue{speciesgentoo} compared to Adelie penguins.\nHowever, there are positive interactions suggesting higher magnitude associations between bill length and depth for both Chinstrap \\statValue{bill_depth_mmispecieschinstrap} and Gentoo penguins \\statValue{bill_depth_mmispeciesgentoo}.\n\nSomething something \\flipperModelValue{intercept}, something something \\depthModelValue{bill_length_mm}.\n\\end{document}\n```\n:::\n\n\n### Some extensions\n\nObviously this was just a simple implementation, but you can extend either the\nR-side processing/formatting or LaTeX-side command as needed.\nFor example, if you have a cumulative link model fit with brms, the threshold\ncoefficients will look like `intercept[1]`, so you might want to adjust these\nto something like `theta1` or `intercept1`.\nAlso, you might want to add some error handling to the `make_latex_switch`\nfunction to make sure the command name you use is wellformed.\n\nOn the LaTeX side, I'm really not very familiar with using expl3 so I don't have\nan idea about how it might interact with other packages, affect compile times,\netc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.0 (2024-04-24 ucrt)\nPlatform: x86_64-w64-mingw32/x64\nRunning under: Windows 11 x64 (build 22631)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.4          broom.mixed_0.2.9.5  lmerTest_3.1-3      \n[4] lme4_1.1-35.3        Matrix_1.7-0         palmerpenguins_0.1.1\n\nloaded via a namespace (and not attached):\n [1] utf8_1.2.4          future_1.33.2       generics_0.1.3     \n [4] tidyr_1.3.1         lattice_0.22-6      listenv_0.9.1      \n [7] digest_0.6.35       magrittr_2.0.3      evaluate_0.23      \n[10] grid_4.4.0          fastmap_1.1.1       jsonlite_1.8.8     \n[13] backports_1.4.1     purrr_1.0.2         fansi_1.0.6        \n[16] scales_1.3.0        codetools_0.2-20    numDeriv_2016.8-1.1\n[19] cli_3.6.2           rlang_1.1.3         parallelly_1.37.1  \n[22] munsell_0.5.1       splines_4.4.0       withr_3.0.0        \n[25] yaml_2.3.8          parallel_4.4.0      tools_4.4.0        \n[28] nloptr_2.0.3        minqa_1.2.6         colorspace_2.1-0   \n[31] ggplot2_3.5.1       forcats_1.0.0       boot_1.3-30        \n[34] globals_0.16.3      broom_1.0.5         vctrs_0.6.5        \n[37] R6_2.5.1            lifecycle_1.0.4     htmlwidgets_1.6.4  \n[40] MASS_7.3-60.2       furrr_0.3.1         pkgconfig_2.0.3    \n[43] pillar_1.9.0        gtable_0.3.5        glue_1.7.0         \n[46] Rcpp_1.0.12         xfun_0.43           tibble_3.2.1       \n[49] tidyselect_1.2.1    rstudioapi_0.16.0   knitr_1.46         \n[52] htmltools_0.5.8.1   nlme_3.1-164        rmarkdown_2.26     \n[55] compiler_4.4.0     \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}