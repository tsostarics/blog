{
  "hash": "3dd8b678a0138b7c9870eb2f420840b5",
  "result": {
    "markdown": "---\ntitle: \"Pulse Labeling\"\nauthor: \"Thomas Sostarics\"\ndate: '2023-01-25'\neditor: source\ndescription: \"This post discusses using non-equi joins to label pitch pulses by an interval on a TextGrid.\"\nbibliography: mybib.bib\ntoc: true\ncategories: ['R','Praat']\ncode-tools: false\ncode-fold: 'show'\nexecute:\n  message: false\n  echo: true\n  warning: false\n---\n\n\nA colleague of mine recently asked for help with a bit of a tricky problem.\nPitch contours, when extracted from an acoustic signal, come in the form of a\ntime series of discretized *pulses*: a (time, frequency) point.\nHowever, these contours occur over varying parts of the spoken sentence.\nIn other words, the rises and falls in pitch occur over different words, syllables,\nand phones-- all of which have varying durations.\nIf we take a pitch contour over a single word from the productions of many\nspeakers, then time normalize them, we don't have access to the relative durations\nand landmarks of the syllables that make up the token.\nFor instance, if two speakers rise from 110Hz to 220Hz over one syllable,\nthis rise will be much steeper if the first syllable is 30% of the time normalized\nduration compared to if the first syllable is 60% of the time normalized duration.\nThe problem then becomes two related problems: \n\n1. How can we know which syllable a pulse appears in? (ie how to label the pulse with the syllable number)\n2. How can we assess a pulse's timestamp relative to the syllable boundaries it occurs in? \n(eg how far into the syllable does the pulse occur)\n\nAs it happens, this problem becomes fairly straightforward when using [non-equi joins](https://www.w3resource.com/sql/joins/perform-a-non-equi-join.php).\nThese are joins (left, right, etc.) that match not merely on equivalence matching,\nbut when more complex logical operations need to be used.\nIn our case, we want to merge information about the pulses and their timestamps\nwith information about the syllable boundary timestamps.\nWe can accomplish this by joining two dataframes based on whether the pulse\ntimestamp is between the start and end timestamps of a particular interval.\n\nIn this post, I'll show how this can be accomplished in R using the new non-equi \njoin functionality added to `{dplyr}` version 1.1.\nIn the process, I'll also show off some tools from the `{rPraat}` package and\nthe `{sosprosody}` package, which I am developing to support the analyses and\ndata processing for my dissertation work.\nThese packages provide some useful functionality for working with PitchTier\nand TextGrid objects from Praat.\nHowever, this functionality can also be accomplished through any non-equi join\nimplementation.\nI'm familiar with the `{fuzzyjoin}` package, and [this post](https://www.r-bloggers.com/2021/02/the-unequalled-joy-of-non-equi-joins/)\nprovides some additional options.\n\n::: {.callout-note}\nI am providing some resynthesized files here from my dissertation work, \ncurrently they're not available publicly but will eventually be on the OSF\nas the work is published and presented. \nI won't be discussing the details further in this post, but I'll note that the\nphone labels were returned by the [Montreal Forced Aligner](https://montreal-forced-aligner.readthedocs.io/en/latest/)\n(@mfa) and the syllable labels were hand coded.\n:::\n\n\n## Required packages\n\nSee below code block for installation of the most relevant packages.\n`{dplyr}` must be version 1.1/the development version (as of this writing) to \nallow for non-equi/fuzzy joins, and so is not (yet) part of a typical \ninstallation of tidyverse.[^installnote]\nRefer to below code block for installation.\n\n[^installnote]: If you're having difficulties installing the development version, \nthere's a few things you can try. You can try restarting your R session, try\nseparately updating any dependencies first (I needed to update `vctrs` separately),\ntry removing dplyr entirely (`remove.packages('dplyr')`). If you're on windows\nand getting a permissions issue, try running R/RStudio as an administrator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# devtools or remotes can be used to install from github\ndevtools::install_github(\"tidyverse/dplyr\")\ninstall.packages('rPRaat')\ndevtools::install_github('tsostarics/sosprosody')\n```\n:::\n\n\nNow we'll load the packages we'll be using.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)      # For joins\nlibrary(rPraat)     # Read functions for textgrids and pitch tiers\nlibrary(sosprosody) # Helpers for working with textgrids and pitch tiers\n\n# These two are part of any tidyverse installation\nlibrary(ggplot2)    # For plotting\nlibrary(purrr)      # For mapping functions\n```\n:::\n\n\n## Example with one file\n\nOur goal: Associate each pitch pulse with an interval on a tier from a TextGrid.\n\nThe approach: Non-equi joins. Given a dataframe for the pitch pulses and a dataframe\nfor a tier from a TextGrid, when a pitch pulse `timepoint` lies between \n`interval_start` and `interval_end`, join `interval_start`, `interval_end`, and \nthe interval `label`.\n\nFirst we'll load our files, located in the `Files` directory.\nBecause I'm working with just one example right now, I'll write the strings out\ndirectly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt_file <- \"Files/branning_1.PitchTier\"\ntg_file <- \"Files/branning_1.TextGrid\"\n```\n:::\n\n\nNow we'll read the PitchTier and TextGrid files into R using `rPraat`.\nThe `sosprosody` package provides new print methods for PitchTier and TextGrid\nobjects, which can also be seen below (these would be displayed in the console).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The default encoding is UTF-8, but there's a common \n# case where Praat encodes files with UTF-16LE\npt <- rPraat::pt.read(pt_file, encoding= \"auto\")\ntg <- rPraat::tg.read(tg_file, encoding = \"auto\")\n```\n:::\n\n::: {.cell .panel-center .column-body-outset-right}\n::: {.cell-output .cell-output-stdout}\n```\nbranning_1.PitchTier: 108 total pitch pulses.\n109|                                                                           |\n   |                                             OOO                           |\n   |                                          OOO   OO                         |\n   |                                      OOOO        OO                       |\n   |                                  OOOO              O                      |\n   |                                OO                   OO                    |\n   |      OOOOOOOOOOOOOOOOOOOOOOOOOO                       OOO                 |\n   |                                                          OOO              |\n   |                                                             OOOO          |\n 65|                                                                 OOO       |\n   0                                                                        1.49 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nbranning_1.TextGrid\n[                words: 4/6 labeled intervals from 0 to 1.49                   ]\n[                phones: 15/17 labeled intervals from 0 to 1.49                ]\n[                nuclear: 1/3 labeled intervals from 0 to 1.49                 ]\n[                syllable: 2/4 labeled intervals from 0 to 1.49                ] \n```\n:::\n:::\n\n\nNow that we have access to our PitchTier and TextGrid, we can convert them\ninto data frame representations, again using `sosprosody`.\nWe'll limit our scope right now to just the `phones` tier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TextGrid as a a dataframe\ntiers <- sosprosody::textgrid_to_dataframes(tg) # List of dfs for each tier\ntier_df <- tiers$phones # Extract a single tier\n\n# Small post processing steps\ntier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\ntier_df$interval_i <- seq_len(nrow(tier_df)) # Assign numeric indices\nhead(tier_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        file interval_start interval_end label interval_i\n1 branning_1      0.0000000    0.1312844                1\n2 branning_1      0.1312844    0.2200000     m          2\n3 branning_1      0.2200000    0.2500000     ɑ          3\n4 branning_1      0.2500000    0.3800000     ʎ          4\n5 branning_1      0.3800000    0.4297910     i          5\n6 branning_1      0.4297910    0.4910510     z          6\n```\n:::\n\n```{.r .cell-code}\n# Pitchtier as a dataframe, we don't need to calculate semitones and ERBs\npt_df <- sosprosody::pitchtier_to_dataframe(pt, \n                                            add_semitones = FALSE,\n                                            add_erbs = FALSE)\nhead(pt_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        file timepoint       hz\n1 branning_1 0.1514512 89.57813\n2 branning_1 0.1614512 89.96063\n3 branning_1 0.1714512 89.98904\n4 branning_1 0.1814512 89.94582\n5 branning_1 0.1914512 89.89566\n6 branning_1 0.2014512 89.87433\n```\n:::\n:::\n\n\nNext we're going to use the new non-equi join functionality from `dplyr`.\nWe want to match up the file in `tier_df` with the correct file in `pt_df`,\nthen check for when the pulse timepoint (i.e., `pt_df$timepoint`) lies after\n`interval_start` and before `interval_end`.\nThe choice of `>=` and `<` is largely arbitrary, you could do `>` and `<=` and\nget the same results unless you have pitch points that lie *exactly* on the \nboundary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabeled_df <- \n  dplyr::left_join(pt_df, \n                   tier_df, \n                   join_by(file, \n                           timepoint >= interval_start, \n                           timepoint < interval_end))\n\nhead(labeled_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        file timepoint       hz interval_start interval_end label interval_i\n1 branning_1 0.1514512 89.57813      0.1312844         0.22     m          2\n2 branning_1 0.1614512 89.96063      0.1312844         0.22     m          2\n3 branning_1 0.1714512 89.98904      0.1312844         0.22     m          2\n4 branning_1 0.1814512 89.94582      0.1312844         0.22     m          2\n5 branning_1 0.1914512 89.89566      0.1312844         0.22     m          2\n6 branning_1 0.2014512 89.87433      0.1312844         0.22     m          2\n```\n:::\n:::\n\n\nTo check our work, let's plot the pitch track to see what our result is like.\nRemember, we wanted to associate each pulse with the interval it appears in.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabeled_df |> \n  ggplot(aes(x = timepoint, y = hz, color = label, group = interval_i)) +\n  geom_line() +\n  geom_point() +\n  theme_bw(base_size = 14) +\n  # Add labels since there's a lot of colors\n  geom_label(data = summarize(group_by(labeled_df, label, interval_i),\n                              timepoint = median(timepoint),\n                              hz = median(hz) - 3),\n             aes(label = label)) +\n  theme(legend.position = 'none')\n```\n\n::: {.cell-output-display}\n![](pulse_labeling_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nLooks great!\nNow we can adapt this same basic workflow of loading our Praat objects,\nconverting to dataframes, and doing a non-equi join and apply it to all the\nfiles in a directory.\nNote that if you extracted F0 measurements using a method other than exporting\nPitchTier files from Praat, then you can still do all the same steps above but\njust omit the part where you read in the PitchTier files.\nUltimately, all we're looking for is a dataframe that says what file(s) we have,\nwhat the pulse timepoints are, and what the frequency values at those timepoints\nare; how we get there doesn't really matter.\n\n## Example with multiple files\n\nHere's a pretty basic wrapper that encapsulates all of the previous steps into\none function and operates over all the files in given directories containing\nTextGrids and PitchTiers.\n\n::: {.callout-tip}\nIf I were to do this for a larger set of files, I would probably split this up\ninto two parts where I first load all the files *then* join them together.\nThe reason being that if there's an issue with joining the files in the below\nfunction, I would have to reload all the files *again* just to try the join again.\nRight now I'm only working with three files, so it doesn't matter too much.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabel_pitch_pulses <- function(textgrid_dir = \"Files\", \n                               pitchtier_dir = \"Files\", \n                               tier = 'phones') {\n  # Note: This will fail if each textgrid does not have a corresponding\n  #       pitch tier file in the pitchtier directory\n  textgrids <- list.files(textgrid_dir, \n                          pattern = \".TextGrid$\",\n                          full.names = TRUE)\n  pitchtiers <- gsub(\".TextGrid$\", \".PitchTier\", textgrids, perl = TRUE)\n  \n  tg_dfs <- \n    map_dfr(textgrids,\n            \\(tg_path) {\n              tg <- rPraat::tg.read(tg_path, encoding = \"auto\")\n              tiers <- sosprosody::textgrid_to_dataframes(tg)\n              tier_df <- tiers[[tier]] \n              \n              # Small post processing steps\n              tier_df$file <- gsub(\".TextGrid\", \"\", tier_df$file, perl = TRUE)\n              tier_df$interval_i <- seq_len(nrow(tier_df))\n              \n              tier_df\n            })\n  \n  pt_dfs <- \n    map_dfr(pitchtiers,\n            \\(pt_path) {\n              pt <- rPraat::pt.read(pt_path, encoding= \"auto\")\n              pt_df <- \n                sosprosody::pitchtier_to_dataframe(pt, \n                                                   add_semitones = FALSE,\n                                                   add_erbs = FALSE)\n              \n              pt_df\n            })\n  \n  # Execute the join\n  left_join(pt_dfs, \n            tg_dfs, \n            join_by(file, \n                    timepoint >= interval_start, \n                    timepoint < interval_end))\n  \n}\n```\n:::\n\n\nAnd now the helper can be used to process all of our files; we'll use it again\nlater when we start working with syllables instead of phones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphone_labeled_df <- label_pitch_pulses()\n```\n:::\n\n\nAs before, we can plot the pitch contours for each of our files to check our work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphone_labeled_df |> \n  ggplot(aes(x = timepoint, y = hz, group = interval_i, color = label)) +\n  geom_line() +\n  geom_point(size = .5) +\n  facet_wrap(~file) +\n  theme_bw(base_size = 14) +\n  geom_text(data = summarize(group_by(phone_labeled_df, file, label, interval_i),\n                             timepoint = median(timepoint),\n                             hz = median(hz) - 4),\n            aes(label = label)) +\n  theme(legend.position = 'none') +\n  coord_fixed(1/50)\n```\n\n::: {.cell-output-display}\n![](pulse_labeling_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nNext I'll show an example of how this might be useful beyond just labeling and\ncoloring our pitch contours by interval.\n\n## Piecewise equal pulses\n\nThis is an example using the `piecewise_interpolate_pulses` function[^pip] from\n`sosprosody` to get equally spaced pulses within each section.[^extract]\nHere I'll get 50 equally spaced pulses for each syllable in all of our words\n(which are all two syllables).\n\n[^pip]: For the interested, this function works by determining where the interval\nboundaries are located for each section as indexed by `section_by`. The\ntimepoints, given by `time_by`, are then used to create a sequence of equally \nspaces values (via `seq(from, to, length.out)`). For each new time value,\nthe corresponding frequency is calculated via linear interpolation of the \nadjacent pulse frequency values given by `.pitchval` (default is `\"hz\"`). This \nis done separately for each group given by `.grouping` (default is `\"file\"`).\n\n[^extract]: Note that `piecewise_extract_pulses` is another similar function, \nbut will not allow for more pulses than what exists in the interval already.\nAdditionally, that function extracts pulses based on modular arithmetic rather\nthan linear interpolation, so any discontinuities are ignored in the result.\n\n::: {.callout-tip}\nAt the time of this writing, a warning will be thrown since `reframe` was added \nto dplyr to take over a deprecated functionality from `summarize`.\nI will fix this in the package at a later data after `dplyr` 1.1 is released. \nThe warning can be ignored though.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyllable_labeled_df <- \n  label_pitch_pulses(tier = 'syllable') |> \n  dplyr::filter(interval_i != 1) |> \n  rename(syllable = label)\n\nsyllable_labeled_df |> \n  # Get fifty equally spaced pulses for each interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = 50,\n                                           time_by = \"timepoint\",\n                                           .pitchval = \"hz\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint, y = hz, color= syllable, shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~file) +\n  coord_fixed(1/50)\n```\n\n::: {.cell-output-display}\n![](pulse_labeling_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nMoreover, `piecewise_interpolate_pulses` can be used to get a certain number\nof pulses *per section*.\nThis allows you to upsample or downsample different parts of the utterance as\nneeded (cf the above example upsampled across the board).\nBelow, I'll get 10 pulses for the first section and 40 pulses for the \nsecond.[^sylnote]\n\n[^sylnote]: Note that because the prenuclear material was associated with an unlabeled tier,\nthe the relevant intervals for the first and second syllables are 2 and 3\ninstead of 1 and 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyllable_labeled_df |> \n  # Get different numbers of pulses by interval\n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"timepoint\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = timepoint,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top')\n```\n\n::: {.cell-output-display}\n![](pulse_labeling_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nIn the above plot, we can tell that at least one of the files have a pitch \ncontour that starts a bit later than the others given the raw time on the x\naxis.\nThis arises due to the slightly longer prenuclear material present in that\nutterance (the other two files were resynthesized from the same source file).\nWe can time normalize these files such that the first syllable from each\ncontour is directly comparable, i.e., they'll all start at 0 and end at 1.\nAnd we can do that separately for the second syllable too.\nIt's more typical to time normalize by the duration of an entire word or\nutterance, but we'll work with a more narrow case of time normalizing within\neach syllable.\nWe address this problem with with much of the tools we've already used so far.\nBelow I use the `time_normalize` function from `sosprosody`, which is a \nconvenience wrapper that does the subtraction and division operations for\ntime normalizing.[^timenorm]\n\n[^timenorm]: For those unfamiliar, the general algorithm is: For each interval\n$i$ with boundary timepoints $t_{i,start}$ and $t_{i,end}$, for each pulse in\nthat interval with timepoints $t_{i,j}$, do $t_{i,j}-t_{i,start}$ to get shifted\ntimepoints $t'_{i,j}$. Then do $t_{i,end}-t_{i,start}$ to get shifted end time\n$t'_{i,end}$. Then divide all of $t'_{i,j}$ by $t'_{i,end}$. The resulting\nvalues then have a range of $[0,1]$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Time normalize by syllable\nsyllable_labeled_df |> \n  group_by(file, interval_i) |> \n  sosprosody::time_normalize(.to = 'time_norm') |> \n  sosprosody::piecewise_interpolate_pulses(section_by = \"syllable\",\n                                           pulses_per_section = c('1' = 10,\n                                                                  '2' = 40),\n                                           time_by = \"time_norm\",\n                                           .grouping = \"file\") |> \n  ggplot(aes(x = time_norm,\n             y = hz,\n             group = file,\n             color = syllable, \n             shape = syllable)) +\n  geom_line() +\n  geom_point(size = 2) +\n  theme_bw(base_size = 14) +\n  theme(legend.position = 'top') +\n  facet_wrap(~syllable) +\n  coord_fixed(1/50)\n```\n\n::: {.cell-output-display}\n![](pulse_labeling_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\nAnd that's all!\nIf you'd like to see a bigger example of how it might be useful to label regions\nof a pitch contour or extract equally spaced samples, you can take a look at\nthe plots on \n[this poster](https://www.tsostarics.com/research/2022_midphon/Sostarics-2022-Midphon.png).\nI've used this approach to extract less pulses from the prenuclear region\nof the utterance and more pulses from the nuclear region, then average multiple\npitch contours across the extracted pulses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.2.0 (2022-04-22 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] purrr_1.0.0           ggplot2_3.4.0         sosprosody_0.0.0.9000\n[4] rPraat_1.3.2-1        dplyr_1.0.99.9000    \n\nloaded via a namespace (and not attached):\n [1] pillar_1.8.1      compiler_4.2.0    tools_4.2.0       bit_4.0.4        \n [5] digest_0.6.31     jsonlite_1.8.4    evaluate_0.19     lifecycle_1.0.3  \n [9] tibble_3.1.8      gtable_0.3.1      pkgconfig_2.0.3   rlang_1.0.6      \n[13] cli_3.5.0         rstudioapi_0.13   parallel_4.2.0    yaml_2.3.6       \n[17] xfun_0.36         fastmap_1.1.0     withr_2.5.0       stringr_1.5.0    \n[21] knitr_1.41        hms_1.1.1         generics_0.1.3    vctrs_0.5.2      \n[25] htmlwidgets_1.5.4 bit64_4.0.5       grid_4.2.0        tidyselect_1.2.0 \n[29] glue_1.6.2        R6_2.5.1          fansi_1.0.4       vroom_1.5.7      \n[33] rmarkdown_2.14    farver_2.1.1      tzdb_0.3.0        readr_2.1.2      \n[37] magrittr_2.0.3    ellipsis_0.3.2    scales_1.2.1      htmltools_0.5.2  \n[41] colorspace_2.0-3  labeling_0.4.2    utf8_1.2.2        stringi_1.7.8    \n[45] munsell_0.5.0     crayon_1.5.2     \n```\n:::\n:::\n",
    "supporting": [
      "pulse_labeling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}